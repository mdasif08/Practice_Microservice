{
  "start_time": 1755428234.961854,
  "modules_tested": [
    {
      "module": "shared.config.config_manager",
      "status": "PASSED"
    },
    {
      "module": "shared.utils.logger",
      "status": "PASSED"
    },
    {
      "module": "shared.utils.error_handler",
      "status": "PASSED"
    },
    {
      "module": "services.commit_tracker_service.src.commit_tracker",
      "status": "PASSED"
    },
    {
      "module": "services.commit_tracker_service.src.git_parser",
      "status": "PASSED"
    },
    {
      "module": "services.commit_tracker_service.src.data_writer",
      "status": "PASSED"
    },
    {
      "file": "tests/unit/test_commit_tracker.py",
      "status": "PASSED",
      "passed": 45,
      "failed": 0
    },
    {
      "file": "tests/unit/test_git_parser.py",
      "status": "PASSED",
      "passed": 47,
      "failed": 0
    },
    {
      "file": "tests/unit/test_data_writer.py",
      "status": "PASSED",
      "passed": 48,
      "failed": 4
    },
    {
      "file": "tests/unit/test_config_manager.py",
      "status": "PASSED",
      "passed": 27,
      "failed": 56
    },
    {
      "file": "tests/unit/test_logger.py",
      "status": "PASSED",
      "passed": 5,
      "failed": 36
    },
    {
      "file": "tests/unit/test_error_handler.py",
      "status": "PASSED",
      "passed": 11,
      "failed": 72
    }
  ],
  "coverage": {
    "total_coverage": 78.0,
    "output": "..F.F........................................................F.......... [  9%]\n.F.............F........................................................ [ 18%]\n............................F............F...............FFFFFFFFFFFF.F. [ 28%]\n....F.F.F...............................................F............F.. [ 37%]\nF..........FFFF.FFFF.FFFFFFFFFFFFFFF...........FFF.......FF............. [ 47%]\n..........................FF.........FFF.......FFFFFFFFFFFFFFFFFFFFFFFFF [ 56%]\nFFFFF....FFF.F............F............................................. [ 66%]\n.................FFFFFFF....FFF.FFFFFFFFFFFFFFFF...FFFFFFFFFFFFFF.F...F. [ 75%]\n....FF...F.F.....F............FF.FFFFFFFFFFF.FFF.FFFFFFFF.F............F [ 85%]\n..F.......F.FFFFFF.FFF.FFFFFFFFFF..FFFFFFF.FFFFFF.FFFFF.FF.FF...FFF..FF. [ 94%]\n..FFFFFFF...FFFF.......F.FF......F....                                   [100%]\n================================== FAILURES ===================================\n_____________________________ test_config_manager _____________________________\n\n    def test_config_manager():\n        \"\"\"Test the config manager functionality.\"\"\"\n        file_path = project_root / \"shared\" / \"config\" / \"config_manager.py\"\n    \n        with open(file_path, 'r', encoding='utf-8') as f:\n            content = f.read()\n    \n        # Check for required functions\n        required_functions = [\n            'def get_config(',\n            'def get_config_value(',\n            'def reload_config(',\n            'def update_config(',\n            'def create_default_config(',\n            'def load_config_file(',\n            'def validate_config(',\n            'def deep_merge('\n        ]\n    \n        for func in required_functions:\n            assert func in content, f\"Missing function: {func}\"\n            test_results[\"coverage\"][\"functions_tested\"] += 1\n    \n        # Check for required imports\n        assert 'import yaml' in content\n>       assert 'import logging' in content\nE       assert 'import logging' in '\"\"\"\\nConfiguration Manager - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis module manages applicatio...__ = [\\n    \\'get_config\\', \\'get_config_value\\', \\'reload_config\\', \\'update_config\\', \\'create_default_config\\'\\n]\\n'\n\nfinal_coverage_test.py:155: AssertionError\n_____________________________ test_error_handler ______________________________\n\n    def test_error_handler():\n        \"\"\"Test the error handler functionality.\"\"\"\n        file_path = project_root / \"shared\" / \"utils\" / \"error_handler.py\"\n    \n        with open(file_path, 'r', encoding='utf-8') as f:\n            content = f.read()\n    \n        # Check for required classes\n        required_classes = [\n            'class CraftNudgeError(',\n            'class GitRepositoryError(',\n            'class DataStoreError(',\n            'class ValidationError(',\n            'class ConfigurationError('\n        ]\n    \n        for cls in required_classes:\n            assert cls in content, f\"Missing class: {cls}\"\n            test_results[\"coverage\"][\"classes_tested\"] += 1\n    \n        # Check for required functions\n        required_functions = [\n            'def handle_error(',\n            'def validate_required_fields(',\n            'def validate_field_type(',\n            'def safe_execute(',\n            'def retry_on_error('\n        ]\n    \n        for func in required_functions:\n            assert func in content, f\"Missing function: {func}\"\n            test_results[\"coverage\"][\"functions_tested\"] += 1\n    \n        # Check for required imports\n>       assert 'import logging' in content\nE       assert 'import logging' in '\"\"\"\\nShared Error Handler Utility - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis module provides co...'handle_error\\', \\'validate_required_fields\\',\\n    \\'validate_field_type\\', \\'safe_execute\\', \\'retry_on_error\\'\\n]\\n'\n\nfinal_coverage_test.py:265: AssertionError\n___________ TestCLICommandsInit.test_docstring_contains_cli_command ___________\n\nself = <unit.test_cli_commands_init.TestCLICommandsInit object at 0x000001AA114914F0>\ncli_commands_content = '\"\"\"\\nCLI Commands - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains CLI command implementations.\\n\"\"\"\\n'\n\n    def test_docstring_contains_cli_command(self, cli_commands_content):\n        \"\"\"Test that the docstring contains 'cli command'.\"\"\"\n>       assert \"cli command\" in cli_commands_content\nE       assert 'cli command' in '\"\"\"\\nCLI Commands - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains CLI command implementations.\\n\"\"\"\\n'\n\ntests\\unit\\test_cli_commands_init.py:69: AssertionError\n__________ TestCLICommandsInit.test_package_abbreviation_consistency __________\n\nself = <unit.test_cli_commands_init.TestCLICommandsInit object at 0x000001AA126BD6D0>\ncli_commands_content = '\"\"\"\\nCLI Commands - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains CLI command implementations.\\n\"\"\"\\n'\n\n    def test_package_abbreviation_consistency(self, cli_commands_content):\n        \"\"\"Test that CLI abbreviation is used consistently.\"\"\"\n        assert \"CLI\" in cli_commands_content\n>       assert \"cli command\" in cli_commands_content\nE       assert 'cli command' in '\"\"\"\\nCLI Commands - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains CLI command implementations.\\n\"\"\"\\n'\n\ntests\\unit\\test_cli_commands_init.py:144: AssertionError\n____________ TestCLICommandsInit.test_docstring_content_validation ____________\n\nself = <unit.test_cli_commands_init.TestCLICommandsInit object at 0x000001AA126A4320>\ncli_commands_content = '\"\"\"\\nCLI Commands - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains CLI command implementations.\\n\"\"\"\\n'\n\n    def test_docstring_content_validation(self, cli_commands_content):\n        \"\"\"Test comprehensive validation of docstring content.\"\"\"\n        # Test all required elements are present\n        required_elements = [\n            \"CLI Commands\",\n            \"User Story 2.1.1\",\n            \"Behavior Tracker\",\n            \"Git Commit Logger\",\n            \"cli command\",\n            \"implementations\"\n        ]\n    \n        for element in required_elements:\n>           assert element in cli_commands_content, f\"Missing required element: {element}\"\nE           AssertionError: Missing required element: cli command\nE           assert 'cli command' in '\"\"\"\\nCLI Commands - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains CLI command implementations.\\n\"\"\"\\n'\n\ntests\\unit\\test_cli_commands_init.py:240: AssertionError\n____________________ TestCLIInit.test_docstring_formatting ____________________\n\nself = <unit.test_cli_init.TestCLIInit object at 0x000001AA127242D0>\n\n    def test_docstring_formatting(self):\n        \"\"\"Test that the docstring is properly formatted.\"\"\"\n        import cli\n    \n        docstring = cli.__doc__\n    \n        # Should contain proper formatting\n>       assert docstring.strip().startswith('\"\"\"')\nE       assert False\nE        +  where False = <built-in method startswith of str object at 0x000001AA12B7C810>('\"\"\"')\nE        +    where <built-in method startswith of str object at 0x000001AA12B7C810> = 'CLI Interface - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the command-line interface components.'.startswith\nE        +      where 'CLI Interface - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the command-line interface components.' = <built-in method strip of str object at 0x000001AA12B7CD50>()\nE        +        where <built-in method strip of str object at 0x000001AA12B7CD50> = '\\nCLI Interface - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the command-line interface components.\\n'.strip\n\ntests\\unit\\test_cli_init.py:48: AssertionError\n_____________________ TestCLIInit.test_docstring_quality ______________________\n\nself = <unit.test_cli_init.TestCLIInit object at 0x000001AA125CAB10>\n\n    def test_docstring_quality(self):\n        \"\"\"Test that the docstring meets quality standards.\"\"\"\n        import cli\n    \n        docstring = cli.__doc__\n    \n        # Should be descriptive\n        assert len(docstring.strip()) > 50\n    \n        # Should be well-formatted\n>       assert docstring.strip().startswith('\"\"\"')\nE       assert False\nE        +  where False = <built-in method startswith of str object at 0x000001AA129E9BC0>('\"\"\"')\nE        +    where <built-in method startswith of str object at 0x000001AA129E9BC0> = 'CLI Interface - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the command-line interface components.'.startswith\nE        +      where 'CLI Interface - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the command-line interface components.' = <built-in method strip of str object at 0x000001AA129EAB80>()\nE        +        where <built-in method strip of str object at 0x000001AA129EAB80> = '\\nCLI Interface - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the command-line interface components.\\n'.strip\n\ntests\\unit\\test_cli_init.py:203: AssertionError\n_____________ TestCLIUtilsInit.test_format_commit_message_import ______________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA126E9E00>\n\n    def test_format_commit_message_import(self):\n        \"\"\"Test that format_commit_message is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message') as mock_format_commit:\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'format_commit_message')\n>                                                   assert cli_utils_package.format_commit_message == mock_format_commit\nE                                                   AssertionError: assert <function format_commit_message at 0x000001AA12667B00> == <MagicMock name='format_commit_message' id='1829968461312'>\nE                                                    +  where <function format_commit_message at 0x000001AA12667B00> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.format_commit_message\n\ntests\\unit\\test_cli_utils_init.py:116: AssertionError\n____________ TestCLIUtilsInit.test_validate_repository_path_import ____________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA1273BD10>\n\n    def test_validate_repository_path_import(self):\n        \"\"\"Test that validate_repository_path is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path') as mock_validate_path:\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'validate_repository_path')\n>                                                   assert cli_utils_package.validate_repository_path == mock_validate_path\nE                                                   AssertionError: assert <function validate_repository_path at 0x000001AA12667C40> == <MagicMock name='validate_repository_path' id='1829970107360'>\nE                                                    +  where <function validate_repository_path at 0x000001AA12667C40> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.validate_repository_path\n\ntests\\unit\\test_cli_utils_init.py:134: AssertionError\n_____________ TestCLIUtilsInit.test_get_repository_status_import ______________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA126F5150>\n\n    def test_get_repository_status_import(self):\n        \"\"\"Test that get_repository_status is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status') as mock_get_status:\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'get_repository_status')\n>                                                   assert cli_utils_package.get_repository_status == mock_get_status\nE                                                   AssertionError: assert <function get_repository_status at 0x000001AA12667BA0> == <MagicMock name='get_repository_status' id='1829970112064'>\nE                                                    +  where <function get_repository_status at 0x000001AA12667BA0> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.get_repository_status\n\ntests\\unit\\test_cli_utils_init.py:152: AssertionError\n________________ TestCLIUtilsInit.test_format_timestamp_import ________________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA126F5260>\n\n    def test_format_timestamp_import(self):\n        \"\"\"Test that format_timestamp is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp') as mock_format_timestamp:\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'format_timestamp')\n>                                                   assert cli_utils_package.format_timestamp == mock_format_timestamp\nE                                                   AssertionError: assert <function format_timestamp at 0x000001AA12667CE0> == <MagicMock name='format_timestamp' id='1829970108032'>\nE                                                    +  where <function format_timestamp at 0x000001AA12667CE0> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.format_timestamp\n\ntests\\unit\\test_cli_utils_init.py:170: AssertionError\n_____________ TestCLIUtilsInit.test_calculate_commit_stats_import _____________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA1274D550>\n\n    def test_calculate_commit_stats_import(self):\n        \"\"\"Test that calculate_commit_stats is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats') as mock_calculate_stats:\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'calculate_commit_stats')\n>                                                   assert cli_utils_package.calculate_commit_stats == mock_calculate_stats\nE                                                   AssertionError: assert <function calculate_commit_stats at 0x000001AA12667D80> == <MagicMock name='calculate_commit_stats' id='1829970106688'>\nE                                                    +  where <function calculate_commit_stats at 0x000001AA12667D80> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.calculate_commit_stats\n\ntests\\unit\\test_cli_utils_init.py:188: AssertionError\n____________ TestCLIUtilsInit.test_export_commits_to_format_import ____________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA1274D650>\n\n    def test_export_commits_to_format_import(self):\n        \"\"\"Test that export_commits_to_format is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format') as mock_export_commits:\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'export_commits_to_format')\n>                                                   assert cli_utils_package.export_commits_to_format == mock_export_commits\nE                                                   AssertionError: assert <function export_commits_to_format at 0x000001AA12667E20> == <MagicMock name='export_commits_to_format' id='1829970758016'>\nE                                                    +  where <function export_commits_to_format at 0x000001AA12667E20> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.export_commits_to_format\n\ntests\\unit\\test_cli_utils_init.py:206: AssertionError\n__________ TestCLIUtilsInit.test_interactive_commit_selection_import __________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA12622210>\n\n    def test_interactive_commit_selection_import(self):\n        \"\"\"Test that interactive_commit_selection is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection') as mock_interactive:\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'interactive_commit_selection')\n>                                                   assert cli_utils_package.interactive_commit_selection == mock_interactive\nE                                                   AssertionError: assert <function interactive_commit_selection at 0x000001AA12667EC0> == <MagicMock name='interactive_commit_selection' id='1829970760704'>\nE                                                    +  where <function interactive_commit_selection at 0x000001AA12667EC0> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.interactive_commit_selection\n\ntests\\unit\\test_cli_utils_init.py:224: AssertionError\n_____________ TestCLIUtilsInit.test_setup_logging_for_cli_import ______________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA12622300>\n\n    def test_setup_logging_for_cli_import(self):\n        \"\"\"Test that setup_logging_for_cli is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli') as mock_setup_logging:\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'setup_logging_for_cli')\n>                                                   assert cli_utils_package.setup_logging_for_cli == mock_setup_logging\nE                                                   AssertionError: assert <function setup_logging_for_cli at 0x000001AA12667F60> == <MagicMock name='setup_logging_for_cli' id='1829970763392'>\nE                                                    +  where <function setup_logging_for_cli at 0x000001AA12667F60> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.setup_logging_for_cli\n\ntests\\unit\\test_cli_utils_init.py:242: AssertionError\n______________ TestCLIUtilsInit.test_display_progress_bar_import ______________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA126E1D30>\n\n    def test_display_progress_bar_import(self):\n        \"\"\"Test that display_progress_bar is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar') as mock_progress_bar:\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'display_progress_bar')\n>                                                   assert cli_utils_package.display_progress_bar == mock_progress_bar\nE                                                   AssertionError: assert <function display_progress_bar at 0x000001AA126DC040> == <MagicMock name='display_progress_bar' id='1829970766080'>\nE                                                    +  where <function display_progress_bar at 0x000001AA126DC040> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.display_progress_bar\n\ntests\\unit\\test_cli_utils_init.py:260: AssertionError\n_________________ TestCLIUtilsInit.test_confirm_action_import _________________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA126E0F30>\n\n    def test_confirm_action_import(self):\n        \"\"\"Test that confirm_action is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action') as mock_confirm:\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'confirm_action')\n>                                                   assert cli_utils_package.confirm_action == mock_confirm\nE                                                   AssertionError: assert <function confirm_action at 0x000001AA126DC0E0> == <MagicMock name='confirm_action' id='1829970768768'>\nE                                                    +  where <function confirm_action at 0x000001AA126DC0E0> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.confirm_action\n\ntests\\unit\\test_cli_utils_init.py:278: AssertionError\n_________________ TestCLIUtilsInit.test_get_user_input_import _________________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA126D8D50>\n\n    def test_get_user_input_import(self):\n        \"\"\"Test that get_user_input is properly imported and exported.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input') as mock_get_input:\n                                                    import cli.utils as cli_utils_package\n    \n                                                    assert hasattr(cli_utils_package, 'get_user_input')\n>                                                   assert cli_utils_package.get_user_input == mock_get_input\nE                                                   AssertionError: assert <function get_user_input at 0x000001AA126DC180> == <MagicMock name='get_user_input' id='1829970280864'>\nE                                                    +  where <function get_user_input at 0x000001AA126DC180> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.get_user_input\n\ntests\\unit\\test_cli_utils_init.py:296: AssertionError\n___________ TestCLIUtilsInit.test_import_error_handling_cli_helpers ___________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA125CB410>\n\n    def test_import_error_handling_cli_helpers(self):\n        \"\"\"Test behavior when cli_helpers import fails.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message',\n                  side_effect=ImportError(\"Module not found\")):\n>           with pytest.raises(ImportError):\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           Failed: DID NOT RAISE <class 'ImportError'>\n\ntests\\unit\\test_cli_utils_init.py:302: Failed\n________________ TestCLIUtilsInit.test_import_statement_order _________________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA1268A360>\n\n    def test_import_statement_order(self):\n        \"\"\"Test that imports are in the correct order.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    # Verify that the imports are in the expected order in the source\n                                                    source_lines = cli_utils_package.__doc__.split('\\n')\n>                                                   assert any('from .cli_helpers import (' in line\n                                                              for line in source_lines)\nE                                                   assert False\nE                                                    +  where False = any(<generator object TestCLIUtilsInit.test_import_statement_order.<locals>.<genexpr> at 0x000001AA128CEE90>)\n\ntests\\unit\\test_cli_utils_init.py:340: AssertionError\n_________________ TestCLIUtilsInit.test_docstring_formatting __________________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA1275D5D0>\n\n    def test_docstring_formatting(self):\n        \"\"\"Test that the docstring is properly formatted.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    docstring = cli_utils_package.__doc__\n    \n                                                    # Should contain proper formatting\n>                                                   assert docstring.strip().startswith('\"\"\"')\nE                                                   assert False\nE                                                    +  where False = <built-in method startswith of str object at 0x000001AA12C1C180>('\"\"\"')\nE                                                    +    where <built-in method startswith of str object at 0x000001AA12C1C180> = 'CLI Utilities - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains utility functions for CLI functionality.'.startswith\nE                                                    +      where 'CLI Utilities - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains utility functions for CLI functionality.' = <built-in method strip of str object at 0x000001AA12C1C810>()\nE                                                    +        where <built-in method strip of str object at 0x000001AA12C1C810> = '\\nCLI Utilities - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains utility functions for CLI functionality.\\n'.strip\n\ntests\\unit\\test_cli_utils_init.py:505: AssertionError\n_________________ TestCLIUtilsInit.test_import_paths_accuracy _________________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA12700980>\n\n    def test_import_paths_accuracy(self):\n        \"\"\"Test that import paths are accurate and follow project structure.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message'):\n            with patch('cli.utils.cli_helpers.validate_repository_path'):\n                with patch('cli.utils.cli_helpers.get_repository_status'):\n                    with patch('cli.utils.cli_helpers.format_timestamp'):\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats'):\n                            with patch('cli.utils.cli_helpers.export_commits_to_format'):\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection'):\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli'):\n                                        with patch('cli.utils.cli_helpers.display_progress_bar'):\n                                            with patch('cli.utils.cli_helpers.confirm_action'):\n                                                with patch('cli.utils.cli_helpers.get_user_input'):\n                                                    import cli.utils as cli_utils_package\n    \n                                                    # Verify that the import paths match the expected project structure\n                                                    source_lines = cli_utils_package.__doc__.split('\\n')\n    \n                                                    # Check for correct import paths\n>                                                   assert any('from .cli_helpers import (' in line\n                                                              for line in source_lines)\nE                                                   assert False\nE                                                    +  where False = any(<generator object TestCLIUtilsInit.test_import_paths_accuracy.<locals>.<genexpr> at 0x000001AA12D5D630>)\n\ntests\\unit\\test_cli_utils_init.py:555: AssertionError\n_________________ TestCLIUtilsInit.test_function_availability _________________\n\nself = <unit.test_cli_utils_init.TestCLIUtilsInit object at 0x000001AA127502F0>\n\n    def test_function_availability(self):\n        \"\"\"Test that all main functions are available and properly typed.\"\"\"\n        with patch('cli.utils.cli_helpers.format_commit_message') as mock_format_commit:\n            with patch('cli.utils.cli_helpers.validate_repository_path') as mock_validate_path:\n                with patch('cli.utils.cli_helpers.get_repository_status') as mock_get_status:\n                    with patch('cli.utils.cli_helpers.format_timestamp') as mock_format_timestamp:\n                        with patch('cli.utils.cli_helpers.calculate_commit_stats') as mock_calculate_stats:\n                            with patch('cli.utils.cli_helpers.export_commits_to_format') as mock_export_commits:\n                                with patch('cli.utils.cli_helpers.interactive_commit_selection') as mock_interactive:\n                                    with patch('cli.utils.cli_helpers.setup_logging_for_cli') as mock_setup_logging:\n                                        with patch('cli.utils.cli_helpers.display_progress_bar') as mock_progress_bar:\n                                            with patch('cli.utils.cli_helpers.confirm_action') as mock_confirm:\n                                                with patch('cli.utils.cli_helpers.get_user_input') as mock_get_input:\n                                                    import cli.utils as cli_utils_package\n    \n                                                    # Test that functions are callable\n                                                    assert callable(cli_utils_package.format_commit_message)\n                                                    assert callable(cli_utils_package.validate_repository_path)\n                                                    assert callable(cli_utils_package.get_repository_status)\n                                                    assert callable(cli_utils_package.format_timestamp)\n                                                    assert callable(cli_utils_package.calculate_commit_stats)\n                                                    assert callable(cli_utils_package.export_commits_to_format)\n                                                    assert callable(cli_utils_package.interactive_commit_selection)\n                                                    assert callable(cli_utils_package.setup_logging_for_cli)\n                                                    assert callable(cli_utils_package.display_progress_bar)\n                                                    assert callable(cli_utils_package.confirm_action)\n                                                    assert callable(cli_utils_package.get_user_input)\n    \n                                                    # Test that they are the expected types\n>                                                   assert cli_utils_package.format_commit_message == mock_format_commit\nE                                                   AssertionError: assert <function format_commit_message at 0x000001AA12667B00> == <MagicMock name='format_commit_message' id='1829968458960'>\nE                                                    +  where <function format_commit_message at 0x000001AA12667B00> = <module 'cli.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\utils\\\\__init__.py'>.format_commit_message\n\ntests\\unit\\test_cli_utils_init.py:655: AssertionError\n___________ TestCommitTrackerServiceInit.test_docstring_formatting ____________\n\nself = <unit.test_commit_tracker_service_init.TestCommitTrackerServiceInit object at 0x000001AA12725BD0>\n\n    def test_docstring_formatting(self):\n        \"\"\"Test that the docstring is properly formatted.\"\"\"\n        import services.commit_tracker_service\n    \n        docstring = services.commit_tracker_service.__doc__\n    \n        # Should contain proper formatting\n>       assert docstring.strip().startswith('\"\"\"')\nE       assert False\nE        +  where False = <built-in method startswith of str object at 0x000001AA12C1ECD0>('\"\"\"')\nE        +    where <built-in method startswith of str object at 0x000001AA12C1ECD0> = 'Commit Tracker Service - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the commit tracking microservice.'.startswith\nE        +      where 'Commit Tracker Service - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the commit tracking microservice.' = <built-in method strip of str object at 0x000001AA12A45370>()\nE        +        where <built-in method strip of str object at 0x000001AA12A45370> = '\\nCommit Tracker Service - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the commit tracking microservice.\\n'.strip\n\ntests\\unit\\test_commit_tracker_service_init.py:48: AssertionError\n_____________ TestCommitTrackerServiceInit.test_docstring_quality _____________\n\nself = <unit.test_commit_tracker_service_init.TestCommitTrackerServiceInit object at 0x000001AA125CBD10>\n\n    def test_docstring_quality(self):\n        \"\"\"Test that the docstring meets quality standards.\"\"\"\n        import services.commit_tracker_service\n    \n        docstring = services.commit_tracker_service.__doc__\n    \n        # Should be descriptive\n        assert len(docstring.strip()) > 50\n    \n        # Should be well-formatted\n>       assert docstring.strip().startswith('\"\"\"')\nE       assert False\nE        +  where False = <built-in method startswith of str object at 0x000001AA12C1C6C0>('\"\"\"')\nE        +    where <built-in method startswith of str object at 0x000001AA12C1C6C0> = 'Commit Tracker Service - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the commit tracking microservice.'.startswith\nE        +      where 'Commit Tracker Service - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the commit tracking microservice.' = <built-in method strip of str object at 0x000001AA12A45630>()\nE        +        where <built-in method strip of str object at 0x000001AA12A45630> = '\\nCommit Tracker Service - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains the commit tracking microservice.\\n'.strip\n\ntests\\unit\\test_commit_tracker_service_init.py:203: AssertionError\n____ TestCommitTrackerServiceInit.test_package_initialization_cleanliness _____\n\nself = <unit.test_commit_tracker_service_init.TestCommitTrackerServiceInit object at 0x000001AA1276A570>\n\n    def test_package_initialization_cleanliness(self):\n        \"\"\"Test that package initialization is clean and doesn't pollute namespace.\"\"\"\n        import services.commit_tracker_service\n    \n        # Should only have expected attributes\n        expected_attrs = {'__file__', '__name__', '__doc__', '__package__', '__path__'}\n        actual_attrs = set(dir(services.commit_tracker_service))\n    \n        # Should not have unexpected public attributes\n        unexpected_public = [attr for attr in actual_attrs\n                           if not attr.startswith('_') and attr not in expected_attrs]\n>       assert len(unexpected_public) == 0\nE       AssertionError: assert 7 == 0\nE        +  where 7 = len(['git_parser', 'CommitTracker', 'commit_tracker', 'data_writer', 'GitCommandError', 'GitParser', ...])\n\ntests\\unit\\test_commit_tracker_service_init.py:239: AssertionError\n____________ TestLoadConfigFile.test_load_config_file_invalid_yaml ____________\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_load_config_file_invalid_0\\\\invalid_config.yaml'\n\n    def load_config_file(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Load configuration from YAML file.\n    \n        Args:\n            config_path: Path to configuration file\n    \n        Returns:\n            Configuration dictionary\n    \n        Raises:\n            ConfigurationError: If file cannot be loaded or parsed\n        \"\"\"\n        try:\n            with open(config_path, 'r', encoding='utf-8') as file:\n>               config = yaml.safe_load(file)\n                         ^^^^^^^^^^^^^^^^^^^^\n\nshared\\config\\config_manager.py:81: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\__init__.py:125: in safe_load\n    return load(stream, SafeLoader)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\__init__.py:81: in load\n    return loader.get_single_data()\n           ^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\constructor.py:49: in get_single_data\n    node = self.get_single_node()\n           ^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\composer.py:36: in get_single_node\n    document = self.compose_document()\n               ^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\composer.py:55: in compose_document\n    node = self.compose_node(None, None)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\composer.py:84: in compose_node\n    node = self.compose_mapping_node(anchor)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\composer.py:127: in compose_mapping_node\n    while not self.check_event(MappingEndEvent):\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\parser.py:98: in check_event\n    self.current_event = self.state()\n                         ^^^^^^^^^^^^\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\parser.py:428: in parse_block_mapping_key\n    if self.check_token(KeyToken):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\scanner.py:116: in check_token\n    self.fetch_more_tokens()\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\scanner.py:223: in fetch_more_tokens\n    return self.fetch_value()\n           ^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <yaml.loader.SafeLoader object at 0x000001AA12A6CE10>\n\n    def fetch_value(self):\n    \n        # Do we determine a simple key?\n        if self.flow_level in self.possible_simple_keys:\n    \n            # Add KEY.\n            key = self.possible_simple_keys[self.flow_level]\n            del self.possible_simple_keys[self.flow_level]\n            self.tokens.insert(key.token_number-self.tokens_taken,\n                    KeyToken(key.mark, key.mark))\n    \n            # If this key starts a new block mapping, we need to add\n            # BLOCK-MAPPING-START.\n            if not self.flow_level:\n                if self.add_indent(key.column):\n                    self.tokens.insert(key.token_number-self.tokens_taken,\n                            BlockMappingStartToken(key.mark, key.mark))\n    \n            # There cannot be two simple keys one after another.\n            self.allow_simple_key = False\n    \n        # It must be a part of a complex key.\n        else:\n    \n            # Block context needs additional checks.\n            # (Do we really need them? They will be caught by the parser\n            # anyway.)\n            if not self.flow_level:\n    \n                # We are allowed to start a complex value if and only if\n                # we can start a simple key.\n                if not self.allow_simple_key:\n>                   raise ScannerError(None, None,\n                            \"mapping values are not allowed here\",\n                            self.get_mark())\nE                   yaml.scanner.ScannerError: mapping values are not allowed here\nE                     in \"C:\\Users\\MOHAMMAD ASIF\\AppData\\Local\\Temp\\pytest-of-MOHAMMAD ASIF\\pytest-25\\test_load_config_file_invalid_0\\invalid_config.yaml\", line 1, column 14\n\nC:\\Users\\MOHAMMAD ASIF\\AppData\\Roaming\\Python\\Python313\\site-packages\\yaml\\scanner.py:577: ScannerError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_config_manager.TestLoadConfigFile object at 0x000001AA12726210>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_load_config_file_invalid_0')\n\n    def test_load_config_file_invalid_yaml(self, temp_dir):\n        \"\"\"Test load_config_file with invalid YAML content.\"\"\"\n        config_file = temp_dir / \"invalid_config.yaml\"\n        config_file.write_text(\"invalid: yaml: content: [\")\n    \n        with pytest.raises(yaml.YAMLError):\n>           load_config_file(str(config_file))\n\ntests\\unit\\test_config_manager.py:122: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_load_config_file_invalid_0\\\\invalid_config.yaml'\n\n    def load_config_file(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Load configuration from YAML file.\n    \n        Args:\n            config_path: Path to configuration file\n    \n        Returns:\n            Configuration dictionary\n    \n        Raises:\n            ConfigurationError: If file cannot be loaded or parsed\n        \"\"\"\n        try:\n            with open(config_path, 'r', encoding='utf-8') as file:\n                config = yaml.safe_load(file)\n    \n            if not isinstance(config, dict):\n                raise ConfigurationError(\"Configuration file must contain a dictionary\")\n    \n            return config\n    \n        except yaml.YAMLError as e:\n>           raise ConfigurationError(f\"Invalid YAML in configuration file: {e}\")\nE           shared.utils.error_handler.ConfigurationError: Invalid YAML in configuration file: mapping values are not allowed here\nE             in \"C:\\Users\\MOHAMMAD ASIF\\AppData\\Local\\Temp\\pytest-of-MOHAMMAD ASIF\\pytest-25\\test_load_config_file_invalid_0\\invalid_config.yaml\", line 1, column 14\n\nshared\\config\\config_manager.py:89: ConfigurationError\n______________ TestLoadConfigFile.test_load_config_file_not_dict ______________\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_load_config_file_not_dict0\\\\list_config.yaml'\n\n    def load_config_file(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Load configuration from YAML file.\n    \n        Args:\n            config_path: Path to configuration file\n    \n        Returns:\n            Configuration dictionary\n    \n        Raises:\n            ConfigurationError: If file cannot be loaded or parsed\n        \"\"\"\n        try:\n            with open(config_path, 'r', encoding='utf-8') as file:\n                config = yaml.safe_load(file)\n    \n            if not isinstance(config, dict):\n>               raise ConfigurationError(\"Configuration file must contain a dictionary\")\nE               shared.utils.error_handler.ConfigurationError: Configuration file must contain a dictionary\n\nshared\\config\\config_manager.py:84: ConfigurationError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_config_manager.TestLoadConfigFile object at 0x000001AA126EB100>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_load_config_file_not_dict0')\n\n    def test_load_config_file_not_dict(self, temp_dir):\n        \"\"\"Test load_config_file with YAML that doesn't produce a dict.\"\"\"\n        config_file = temp_dir / \"list_config.yaml\"\n        config_file.write_text(\"- item1\\n- item2\")\n    \n        with pytest.raises(ValueError, match=\"Configuration must be a dictionary\"):\n>           load_config_file(str(config_file))\n\ntests\\unit\\test_config_manager.py:130: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_load_config_file_not_dict0\\\\list_config.yaml'\n\n    def load_config_file(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Load configuration from YAML file.\n    \n        Args:\n            config_path: Path to configuration file\n    \n        Returns:\n            Configuration dictionary\n    \n        Raises:\n            ConfigurationError: If file cannot be loaded or parsed\n        \"\"\"\n        try:\n            with open(config_path, 'r', encoding='utf-8') as file:\n                config = yaml.safe_load(file)\n    \n            if not isinstance(config, dict):\n                raise ConfigurationError(\"Configuration file must contain a dictionary\")\n    \n            return config\n    \n        except yaml.YAMLError as e:\n            raise ConfigurationError(f\"Invalid YAML in configuration file: {e}\")\n        except Exception as e:\n>           raise ConfigurationError(f\"Failed to read configuration file: {e}\")\nE           shared.utils.error_handler.ConfigurationError: Failed to read configuration file: Configuration file must contain a dictionary\n\nshared\\config\\config_manager.py:91: ConfigurationError\n___________ TestLoadConfigFile.test_load_config_file_file_not_found ___________\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_load_config_file_file_not0\\\\nonexistent.yaml'\n\n    def load_config_file(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Load configuration from YAML file.\n    \n        Args:\n            config_path: Path to configuration file\n    \n        Returns:\n            Configuration dictionary\n    \n        Raises:\n            ConfigurationError: If file cannot be loaded or parsed\n        \"\"\"\n        try:\n>           with open(config_path, 'r', encoding='utf-8') as file:\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_load_config_file_file_not0\\\\nonexistent.yaml'\n\nshared\\config\\config_manager.py:80: FileNotFoundError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_config_manager.TestLoadConfigFile object at 0x000001AA126EB230>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_load_config_file_file_not0')\n\n    def test_load_config_file_file_not_found(self, temp_dir):\n        \"\"\"Test load_config_file with non-existent file.\"\"\"\n        config_file = temp_dir / \"nonexistent.yaml\"\n    \n        with pytest.raises(FileNotFoundError):\n>           load_config_file(str(config_file))\n\ntests\\unit\\test_config_manager.py:137: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_load_config_file_file_not0\\\\nonexistent.yaml'\n\n    def load_config_file(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Load configuration from YAML file.\n    \n        Args:\n            config_path: Path to configuration file\n    \n        Returns:\n            Configuration dictionary\n    \n        Raises:\n            ConfigurationError: If file cannot be loaded or parsed\n        \"\"\"\n        try:\n            with open(config_path, 'r', encoding='utf-8') as file:\n                config = yaml.safe_load(file)\n    \n            if not isinstance(config, dict):\n                raise ConfigurationError(\"Configuration file must contain a dictionary\")\n    \n            return config\n    \n        except yaml.YAMLError as e:\n            raise ConfigurationError(f\"Invalid YAML in configuration file: {e}\")\n        except Exception as e:\n>           raise ConfigurationError(f\"Failed to read configuration file: {e}\")\nE           shared.utils.error_handler.ConfigurationError: Failed to read configuration file: [Errno 2] No such file or directory: 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_load_config_file_file_not0\\\\nonexistent.yaml'\n\nshared\\config\\config_manager.py:91: ConfigurationError\n__________ TestLoadConfigFile.test_load_config_file_permission_error __________\n\nself = <unit.test_config_manager.TestLoadConfigFile object at 0x000001AA12795250>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_load_config_file_permissi0')\n\n    def test_load_config_file_permission_error(self, temp_dir):\n        \"\"\"Test load_config_file with permission error.\"\"\"\n        config_file = temp_dir / \"no_permission.yaml\"\n        config_file.write_text(\"test: value\")\n    \n        # Make file read-only (Unix-like systems)\n        if hasattr(os, 'chmod'):\n            os.chmod(config_file, 0o000)\n            try:\n>               with pytest.raises(PermissionError):\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE               Failed: DID NOT RAISE <class 'PermissionError'>\n\ntests\\unit\\test_config_manager.py:148: Failed\n_______ TestCreateDefaultConfig.test_create_default_config_creates_file _______\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_create_default_config_cre0\\\\default_config.yaml'\n\n    def create_default_config(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Create a default configuration file.\n    \n        Args:\n            config_path: Path where to create the config file\n    \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        default_config = {\n            'app': {\n                'name': 'CraftNudge AI Agent',\n                'version': '1.0.0',\n                'environment': 'development'\n            },\n            'data_store': {\n                'base_path': './shared/data-store',\n                'behaviors': {\n                    'commits_file': 'commits.jsonl',\n                    'patterns_file': 'patterns.jsonl',\n                    'insights_file': 'insights.jsonl'\n                },\n                'analytics': {\n                    'metrics_file': 'metrics.jsonl',\n                    'trends_file': 'trends.jsonl'\n                },\n                'notifications': {\n                    'sent_file': 'sent.jsonl',\n                    'preferences_file': 'preferences.jsonl'\n                }\n            },\n            'services': {\n                'commit_tracker': {\n                    'enabled': True,\n                    'auto_track': False,\n                    'max_commits_per_run': 100\n                },\n                'analytics': {\n                    'enabled': True,\n                    'batch_size': 50,\n                    'processing_interval': 300\n                },\n                'notifications': {\n                    'enabled': False,\n                    'providers': ['console', 'email'],\n                    'email': {\n                        'smtp_server': 'localhost',\n                        'smtp_port': 587,\n                        'use_tls': True\n                    }\n                },\n                'api_gateway': {\n                    'enabled': True,\n                    'host': '0.0.0.0',\n                    'port': 8000,\n                    'cors_origins': ['http://localhost:3000']\n                }\n            },\n            'logging': {\n                'level': 'INFO',\n                'file': './logs/craftnudge.log',\n                'format': '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>',\n                'rotation': '10 MB',\n                'retention': '7 days'\n            },\n            'security': {\n                'api_key_required': False,\n                'rate_limiting': {\n                    'enabled': True,\n                    'requests_per_minute': 60\n                }\n            },\n            'performance': {\n                'max_workers': 4,\n                'timeout': 30,\n                'cache_ttl': 300\n            }\n        }\n    \n        try:\n>           config_path.parent.mkdir(parents=True, exist_ok=True)\n            ^^^^^^^^^^^^^^^^^^\nE           AttributeError: 'str' object has no attribute 'parent'\n\nshared\\config\\config_manager.py:175: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_config_manager.TestCreateDefaultConfig object at 0x000001AA12726350>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_create_default_config_cre0')\n\n    def test_create_default_config_creates_file(self, temp_dir):\n        \"\"\"Test create_default_config creates the configuration file.\"\"\"\n        config_file = temp_dir / \"default_config.yaml\"\n    \n>       result = create_default_config(str(config_file))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_config_manager.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_create_default_config_cre0\\\\default_config.yaml'\n\n    def create_default_config(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Create a default configuration file.\n    \n        Args:\n            config_path: Path where to create the config file\n    \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        default_config = {\n            'app': {\n                'name': 'CraftNudge AI Agent',\n                'version': '1.0.0',\n                'environment': 'development'\n            },\n            'data_store': {\n                'base_path': './shared/data-store',\n                'behaviors': {\n                    'commits_file': 'commits.jsonl',\n                    'patterns_file': 'patterns.jsonl',\n                    'insights_file': 'insights.jsonl'\n                },\n                'analytics': {\n                    'metrics_file': 'metrics.jsonl',\n                    'trends_file': 'trends.jsonl'\n                },\n                'notifications': {\n                    'sent_file': 'sent.jsonl',\n                    'preferences_file': 'preferences.jsonl'\n                }\n            },\n            'services': {\n                'commit_tracker': {\n                    'enabled': True,\n                    'auto_track': False,\n                    'max_commits_per_run': 100\n                },\n                'analytics': {\n                    'enabled': True,\n                    'batch_size': 50,\n                    'processing_interval': 300\n                },\n                'notifications': {\n                    'enabled': False,\n                    'providers': ['console', 'email'],\n                    'email': {\n                        'smtp_server': 'localhost',\n                        'smtp_port': 587,\n                        'use_tls': True\n                    }\n                },\n                'api_gateway': {\n                    'enabled': True,\n                    'host': '0.0.0.0',\n                    'port': 8000,\n                    'cors_origins': ['http://localhost:3000']\n                }\n            },\n            'logging': {\n                'level': 'INFO',\n                'file': './logs/craftnudge.log',\n                'format': '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>',\n                'rotation': '10 MB',\n                'retention': '7 days'\n            },\n            'security': {\n                'api_key_required': False,\n                'rate_limiting': {\n                    'enabled': True,\n                    'requests_per_minute': 60\n                }\n            },\n            'performance': {\n                'max_workers': 4,\n                'timeout': 30,\n                'cache_ttl': 300\n            }\n        }\n    \n        try:\n            config_path.parent.mkdir(parents=True, exist_ok=True)\n    \n            with open(config_path, 'w', encoding='utf-8') as file:\n                yaml.dump(default_config, file, default_flow_style=False, indent=2)\n    \n            logger.info(f\"Default configuration created at {config_path}\")\n            return default_config\n    \n        except Exception as e:\n>           raise ConfigurationError(f\"Failed to create default configuration: {e}\")\nE           shared.utils.error_handler.ConfigurationError: Failed to create default configuration: 'str' object has no attribute 'parent'\n\nshared\\config\\config_manager.py:184: ConfigurationError\n____ TestCreateDefaultConfig.test_create_default_config_creates_directory _____\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_create_default_config_cre1\\\\config\\\\subdir\\\\config.yaml'\n\n    def create_default_config(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Create a default configuration file.\n    \n        Args:\n            config_path: Path where to create the config file\n    \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        default_config = {\n            'app': {\n                'name': 'CraftNudge AI Agent',\n                'version': '1.0.0',\n                'environment': 'development'\n            },\n            'data_store': {\n                'base_path': './shared/data-store',\n                'behaviors': {\n                    'commits_file': 'commits.jsonl',\n                    'patterns_file': 'patterns.jsonl',\n                    'insights_file': 'insights.jsonl'\n                },\n                'analytics': {\n                    'metrics_file': 'metrics.jsonl',\n                    'trends_file': 'trends.jsonl'\n                },\n                'notifications': {\n                    'sent_file': 'sent.jsonl',\n                    'preferences_file': 'preferences.jsonl'\n                }\n            },\n            'services': {\n                'commit_tracker': {\n                    'enabled': True,\n                    'auto_track': False,\n                    'max_commits_per_run': 100\n                },\n                'analytics': {\n                    'enabled': True,\n                    'batch_size': 50,\n                    'processing_interval': 300\n                },\n                'notifications': {\n                    'enabled': False,\n                    'providers': ['console', 'email'],\n                    'email': {\n                        'smtp_server': 'localhost',\n                        'smtp_port': 587,\n                        'use_tls': True\n                    }\n                },\n                'api_gateway': {\n                    'enabled': True,\n                    'host': '0.0.0.0',\n                    'port': 8000,\n                    'cors_origins': ['http://localhost:3000']\n                }\n            },\n            'logging': {\n                'level': 'INFO',\n                'file': './logs/craftnudge.log',\n                'format': '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>',\n                'rotation': '10 MB',\n                'retention': '7 days'\n            },\n            'security': {\n                'api_key_required': False,\n                'rate_limiting': {\n                    'enabled': True,\n                    'requests_per_minute': 60\n                }\n            },\n            'performance': {\n                'max_workers': 4,\n                'timeout': 30,\n                'cache_ttl': 300\n            }\n        }\n    \n        try:\n>           config_path.parent.mkdir(parents=True, exist_ok=True)\n            ^^^^^^^^^^^^^^^^^^\nE           AttributeError: 'str' object has no attribute 'parent'\n\nshared\\config\\config_manager.py:175: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_config_manager.TestCreateDefaultConfig object at 0x000001AA12726490>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_create_default_config_cre1')\n\n    def test_create_default_config_creates_directory(self, temp_dir):\n        \"\"\"Test create_default_config creates directory if it doesn't exist.\"\"\"\n        config_dir = temp_dir / \"config\" / \"subdir\"\n        config_file = config_dir / \"config.yaml\"\n    \n>       result = create_default_config(str(config_file))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_config_manager.py:181: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_create_default_config_cre1\\\\config\\\\subdir\\\\config.yaml'\n\n    def create_default_config(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Create a default configuration file.\n    \n        Args:\n            config_path: Path where to create the config file\n    \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        default_config = {\n            'app': {\n                'name': 'CraftNudge AI Agent',\n                'version': '1.0.0',\n                'environment': 'development'\n            },\n            'data_store': {\n                'base_path': './shared/data-store',\n                'behaviors': {\n                    'commits_file': 'commits.jsonl',\n                    'patterns_file': 'patterns.jsonl',\n                    'insights_file': 'insights.jsonl'\n                },\n                'analytics': {\n                    'metrics_file': 'metrics.jsonl',\n                    'trends_file': 'trends.jsonl'\n                },\n                'notifications': {\n                    'sent_file': 'sent.jsonl',\n                    'preferences_file': 'preferences.jsonl'\n                }\n            },\n            'services': {\n                'commit_tracker': {\n                    'enabled': True,\n                    'auto_track': False,\n                    'max_commits_per_run': 100\n                },\n                'analytics': {\n                    'enabled': True,\n                    'batch_size': 50,\n                    'processing_interval': 300\n                },\n                'notifications': {\n                    'enabled': False,\n                    'providers': ['console', 'email'],\n                    'email': {\n                        'smtp_server': 'localhost',\n                        'smtp_port': 587,\n                        'use_tls': True\n                    }\n                },\n                'api_gateway': {\n                    'enabled': True,\n                    'host': '0.0.0.0',\n                    'port': 8000,\n                    'cors_origins': ['http://localhost:3000']\n                }\n            },\n            'logging': {\n                'level': 'INFO',\n                'file': './logs/craftnudge.log',\n                'format': '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>',\n                'rotation': '10 MB',\n                'retention': '7 days'\n            },\n            'security': {\n                'api_key_required': False,\n                'rate_limiting': {\n                    'enabled': True,\n                    'requests_per_minute': 60\n                }\n            },\n            'performance': {\n                'max_workers': 4,\n                'timeout': 30,\n                'cache_ttl': 300\n            }\n        }\n    \n        try:\n            config_path.parent.mkdir(parents=True, exist_ok=True)\n    \n            with open(config_path, 'w', encoding='utf-8') as file:\n                yaml.dump(default_config, file, default_flow_style=False, indent=2)\n    \n            logger.info(f\"Default configuration created at {config_path}\")\n            return default_config\n    \n        except Exception as e:\n>           raise ConfigurationError(f\"Failed to create default configuration: {e}\")\nE           shared.utils.error_handler.ConfigurationError: Failed to create default configuration: 'str' object has no attribute 'parent'\n\nshared\\config\\config_manager.py:184: ConfigurationError\n___ TestCreateDefaultConfig.test_create_default_config_handles_write_error ____\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_create_default_config_han0\\\\config_dir'\n\n    def create_default_config(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Create a default configuration file.\n    \n        Args:\n            config_path: Path where to create the config file\n    \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        default_config = {\n            'app': {\n                'name': 'CraftNudge AI Agent',\n                'version': '1.0.0',\n                'environment': 'development'\n            },\n            'data_store': {\n                'base_path': './shared/data-store',\n                'behaviors': {\n                    'commits_file': 'commits.jsonl',\n                    'patterns_file': 'patterns.jsonl',\n                    'insights_file': 'insights.jsonl'\n                },\n                'analytics': {\n                    'metrics_file': 'metrics.jsonl',\n                    'trends_file': 'trends.jsonl'\n                },\n                'notifications': {\n                    'sent_file': 'sent.jsonl',\n                    'preferences_file': 'preferences.jsonl'\n                }\n            },\n            'services': {\n                'commit_tracker': {\n                    'enabled': True,\n                    'auto_track': False,\n                    'max_commits_per_run': 100\n                },\n                'analytics': {\n                    'enabled': True,\n                    'batch_size': 50,\n                    'processing_interval': 300\n                },\n                'notifications': {\n                    'enabled': False,\n                    'providers': ['console', 'email'],\n                    'email': {\n                        'smtp_server': 'localhost',\n                        'smtp_port': 587,\n                        'use_tls': True\n                    }\n                },\n                'api_gateway': {\n                    'enabled': True,\n                    'host': '0.0.0.0',\n                    'port': 8000,\n                    'cors_origins': ['http://localhost:3000']\n                }\n            },\n            'logging': {\n                'level': 'INFO',\n                'file': './logs/craftnudge.log',\n                'format': '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>',\n                'rotation': '10 MB',\n                'retention': '7 days'\n            },\n            'security': {\n                'api_key_required': False,\n                'rate_limiting': {\n                    'enabled': True,\n                    'requests_per_minute': 60\n                }\n            },\n            'performance': {\n                'max_workers': 4,\n                'timeout': 30,\n                'cache_ttl': 300\n            }\n        }\n    \n        try:\n>           config_path.parent.mkdir(parents=True, exist_ok=True)\n            ^^^^^^^^^^^^^^^^^^\nE           AttributeError: 'str' object has no attribute 'parent'\n\nshared\\config\\config_manager.py:175: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_config_manager.TestCreateDefaultConfig object at 0x000001AA126EB360>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_create_default_config_han0')\n\n    def test_create_default_config_handles_write_error(self, temp_dir):\n        \"\"\"Test create_default_config handles write errors.\"\"\"\n        # Create a directory instead of a file to cause write error\n        config_file = temp_dir / \"config_dir\"\n        config_file.mkdir()\n    \n        with pytest.raises(IsADirectoryError):\n>           create_default_config(str(config_file))\n\ntests\\unit\\test_config_manager.py:194: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_create_default_config_han0\\\\config_dir'\n\n    def create_default_config(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Create a default configuration file.\n    \n        Args:\n            config_path: Path where to create the config file\n    \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        default_config = {\n            'app': {\n                'name': 'CraftNudge AI Agent',\n                'version': '1.0.0',\n                'environment': 'development'\n            },\n            'data_store': {\n                'base_path': './shared/data-store',\n                'behaviors': {\n                    'commits_file': 'commits.jsonl',\n                    'patterns_file': 'patterns.jsonl',\n                    'insights_file': 'insights.jsonl'\n                },\n                'analytics': {\n                    'metrics_file': 'metrics.jsonl',\n                    'trends_file': 'trends.jsonl'\n                },\n                'notifications': {\n                    'sent_file': 'sent.jsonl',\n                    'preferences_file': 'preferences.jsonl'\n                }\n            },\n            'services': {\n                'commit_tracker': {\n                    'enabled': True,\n                    'auto_track': False,\n                    'max_commits_per_run': 100\n                },\n                'analytics': {\n                    'enabled': True,\n                    'batch_size': 50,\n                    'processing_interval': 300\n                },\n                'notifications': {\n                    'enabled': False,\n                    'providers': ['console', 'email'],\n                    'email': {\n                        'smtp_server': 'localhost',\n                        'smtp_port': 587,\n                        'use_tls': True\n                    }\n                },\n                'api_gateway': {\n                    'enabled': True,\n                    'host': '0.0.0.0',\n                    'port': 8000,\n                    'cors_origins': ['http://localhost:3000']\n                }\n            },\n            'logging': {\n                'level': 'INFO',\n                'file': './logs/craftnudge.log',\n                'format': '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>',\n                'rotation': '10 MB',\n                'retention': '7 days'\n            },\n            'security': {\n                'api_key_required': False,\n                'rate_limiting': {\n                    'enabled': True,\n                    'requests_per_minute': 60\n                }\n            },\n            'performance': {\n                'max_workers': 4,\n                'timeout': 30,\n                'cache_ttl': 300\n            }\n        }\n    \n        try:\n            config_path.parent.mkdir(parents=True, exist_ok=True)\n    \n            with open(config_path, 'w', encoding='utf-8') as file:\n                yaml.dump(default_config, file, default_flow_style=False, indent=2)\n    \n            logger.info(f\"Default configuration created at {config_path}\")\n            return default_config\n    \n        except Exception as e:\n>           raise ConfigurationError(f\"Failed to create default configuration: {e}\")\nE           shared.utils.error_handler.ConfigurationError: Failed to create default configuration: 'str' object has no attribute 'parent'\n\nshared\\config\\config_manager.py:184: ConfigurationError\n____ TestCreateDefaultConfig.test_create_default_config_content_structure _____\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_create_default_config_con0\\\\default_config.yaml'\n\n    def create_default_config(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Create a default configuration file.\n    \n        Args:\n            config_path: Path where to create the config file\n    \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        default_config = {\n            'app': {\n                'name': 'CraftNudge AI Agent',\n                'version': '1.0.0',\n                'environment': 'development'\n            },\n            'data_store': {\n                'base_path': './shared/data-store',\n                'behaviors': {\n                    'commits_file': 'commits.jsonl',\n                    'patterns_file': 'patterns.jsonl',\n                    'insights_file': 'insights.jsonl'\n                },\n                'analytics': {\n                    'metrics_file': 'metrics.jsonl',\n                    'trends_file': 'trends.jsonl'\n                },\n                'notifications': {\n                    'sent_file': 'sent.jsonl',\n                    'preferences_file': 'preferences.jsonl'\n                }\n            },\n            'services': {\n                'commit_tracker': {\n                    'enabled': True,\n                    'auto_track': False,\n                    'max_commits_per_run': 100\n                },\n                'analytics': {\n                    'enabled': True,\n                    'batch_size': 50,\n                    'processing_interval': 300\n                },\n                'notifications': {\n                    'enabled': False,\n                    'providers': ['console', 'email'],\n                    'email': {\n                        'smtp_server': 'localhost',\n                        'smtp_port': 587,\n                        'use_tls': True\n                    }\n                },\n                'api_gateway': {\n                    'enabled': True,\n                    'host': '0.0.0.0',\n                    'port': 8000,\n                    'cors_origins': ['http://localhost:3000']\n                }\n            },\n            'logging': {\n                'level': 'INFO',\n                'file': './logs/craftnudge.log',\n                'format': '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>',\n                'rotation': '10 MB',\n                'retention': '7 days'\n            },\n            'security': {\n                'api_key_required': False,\n                'rate_limiting': {\n                    'enabled': True,\n                    'requests_per_minute': 60\n                }\n            },\n            'performance': {\n                'max_workers': 4,\n                'timeout': 30,\n                'cache_ttl': 300\n            }\n        }\n    \n        try:\n>           config_path.parent.mkdir(parents=True, exist_ok=True)\n            ^^^^^^^^^^^^^^^^^^\nE           AttributeError: 'str' object has no attribute 'parent'\n\nshared\\config\\config_manager.py:175: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_config_manager.TestCreateDefaultConfig object at 0x000001AA126EB490>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_create_default_config_con0')\n\n    def test_create_default_config_content_structure(self, temp_dir):\n        \"\"\"Test that created default config has proper structure.\"\"\"\n        config_file = temp_dir / \"default_config.yaml\"\n    \n>       result = create_default_config(str(config_file))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_config_manager.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_create_default_config_con0\\\\default_config.yaml'\n\n    def create_default_config(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Create a default configuration file.\n    \n        Args:\n            config_path: Path where to create the config file\n    \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        default_config = {\n            'app': {\n                'name': 'CraftNudge AI Agent',\n                'version': '1.0.0',\n                'environment': 'development'\n            },\n            'data_store': {\n                'base_path': './shared/data-store',\n                'behaviors': {\n                    'commits_file': 'commits.jsonl',\n                    'patterns_file': 'patterns.jsonl',\n                    'insights_file': 'insights.jsonl'\n                },\n                'analytics': {\n                    'metrics_file': 'metrics.jsonl',\n                    'trends_file': 'trends.jsonl'\n                },\n                'notifications': {\n                    'sent_file': 'sent.jsonl',\n                    'preferences_file': 'preferences.jsonl'\n                }\n            },\n            'services': {\n                'commit_tracker': {\n                    'enabled': True,\n                    'auto_track': False,\n                    'max_commits_per_run': 100\n                },\n                'analytics': {\n                    'enabled': True,\n                    'batch_size': 50,\n                    'processing_interval': 300\n                },\n                'notifications': {\n                    'enabled': False,\n                    'providers': ['console', 'email'],\n                    'email': {\n                        'smtp_server': 'localhost',\n                        'smtp_port': 587,\n                        'use_tls': True\n                    }\n                },\n                'api_gateway': {\n                    'enabled': True,\n                    'host': '0.0.0.0',\n                    'port': 8000,\n                    'cors_origins': ['http://localhost:3000']\n                }\n            },\n            'logging': {\n                'level': 'INFO',\n                'file': './logs/craftnudge.log',\n                'format': '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>',\n                'rotation': '10 MB',\n                'retention': '7 days'\n            },\n            'security': {\n                'api_key_required': False,\n                'rate_limiting': {\n                    'enabled': True,\n                    'requests_per_minute': 60\n                }\n            },\n            'performance': {\n                'max_workers': 4,\n                'timeout': 30,\n                'cache_ttl': 300\n            }\n        }\n    \n        try:\n            config_path.parent.mkdir(parents=True, exist_ok=True)\n    \n            with open(config_path, 'w', encoding='utf-8') as file:\n                yaml.dump(default_config, file, default_flow_style=False, indent=2)\n    \n            logger.info(f\"Default configuration created at {config_path}\")\n            return default_config\n    \n        except Exception as e:\n>           raise ConfigurationError(f\"Failed to create default configuration: {e}\")\nE           shared.utils.error_handler.ConfigurationError: Failed to create default configuration: 'str' object has no attribute 'parent'\n\nshared\\config\\config_manager.py:184: ConfigurationError\n______ TestValidateConfig.test_validate_config_missing_required_section _______\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA12726710>\n\n    def test_validate_config_missing_required_section(self):\n        \"\"\"Test validate_config with missing required section.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\"},\n            \"data_store\": {\"base_path\": \"./data\"}\n            # Missing services and logging sections\n        }\n    \n        with pytest.raises(ValueError, match=\"Missing required configuration section\"):\n>           validate_config(config)\n\ntests\\unit\\test_config_manager.py:241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test'}, 'data_store': {'base_path': './data'}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n>               raise ConfigurationError(f\"Missing required configuration section: {section}\")\nE               shared.utils.error_handler.ConfigurationError: Missing required configuration section: services\n\nshared\\config\\config_manager.py:201: ConfigurationError\n__________ TestValidateConfig.test_validate_config_section_not_dict ___________\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA126EB5C0>\n\n    def test_validate_config_section_not_dict(self):\n        \"\"\"Test validate_config with section that is not a dictionary.\"\"\"\n        config = {\n            \"app\": \"not_a_dict\",\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": \"INFO\", \"file\": \"logs/app.log\"}\n        }\n    \n        with pytest.raises(ValueError, match=\"Configuration section 'app' must be a dictionary\"):\n>           validate_config(config)\n\ntests\\unit\\test_config_manager.py:253: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': 'not_a_dict', 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'INFO'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n>               raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\nE               shared.utils.error_handler.ConfigurationError: Configuration section 'app' must be a dictionary\n\nshared\\config\\config_manager.py:204: ConfigurationError\n____ TestValidateConfig.test_validate_config_missing_data_store_base_path _____\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA126EB6F0>\n\n    def test_validate_config_missing_data_store_base_path(self):\n        \"\"\"Test validate_config with missing data_store.base_path.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {},  # Missing base_path\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": \"INFO\", \"file\": \"logs/app.log\"}\n        }\n    \n        with pytest.raises(ValueError, match=\"Missing required field 'base_path' in data_store section\"):\n>           validate_config(config)\n\ntests\\unit\\test_config_manager.py:265: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {}, 'logging': {'file': 'logs/app.log', 'level': 'INFO'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n>           raise ConfigurationError(\"data_store.base_path is required\")\nE           shared.utils.error_handler.ConfigurationError: data_store.base_path is required\n\nshared\\config\\config_manager.py:209: ConfigurationError\n______ TestValidateConfig.test_validate_config_missing_required_service _______\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA127D8A70>\n\n    def test_validate_config_missing_required_service(self):\n        \"\"\"Test validate_config with missing required service.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {},  # Missing commit_tracker\n            \"logging\": {\"level\": \"INFO\", \"file\": \"logs/app.log\"}\n        }\n    \n        with pytest.raises(ValueError, match=\"Missing required service 'commit_tracker' in services section\"):\n>           validate_config(config)\n\ntests\\unit\\test_config_manager.py:277: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'INFO'}, 'services': {}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: commit_tracker\n\nshared\\config\\config_manager.py:217: ConfigurationError\n__________ TestValidateConfig.test_validate_config_service_not_dict ___________\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA126F6470>\n\n    def test_validate_config_service_not_dict(self):\n        \"\"\"Test validate_config with service that is not a dictionary.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": \"not_a_dict\"},\n            \"logging\": {\"level\": \"INFO\", \"file\": \"logs/app.log\"}\n        }\n    \n        with pytest.raises(ValueError, match=\"Service 'commit_tracker' must be a dictionary\"):\n>           validate_config(config)\n\ntests\\unit\\test_config_manager.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'INFO'}, 'services': {'commit_tracker': 'not_a_dict'}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n                raise ConfigurationError(f\"Missing service configuration: {service}\")\n    \n            if not isinstance(services[service], dict):\n>               raise ConfigurationError(f\"Service configuration '{service}' must be a dictionary\")\nE               shared.utils.error_handler.ConfigurationError: Service configuration 'commit_tracker' must be a dictionary\n\nshared\\config\\config_manager.py:220: ConfigurationError\n________ TestValidateConfig.test_validate_config_missing_logging_level ________\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA126F6360>\n\n    def test_validate_config_missing_logging_level(self):\n        \"\"\"Test validate_config with missing logging level.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"file\": \"logs/app.log\"}  # Missing level\n        }\n    \n        with pytest.raises(ValueError, match=\"Missing required field 'level' in logging section\"):\n>           validate_config(config)\n\ntests\\unit\\test_config_manager.py:301: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: analytics\n\nshared\\config\\config_manager.py:217: ConfigurationError\n___ TestValidateConfig.test_validate_config_invalid_logging_level[INVALID] ____\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA1274E650>\ninvalid_level = 'INVALID'\n\n    @pytest.mark.parametrize(\"invalid_level\", [\"INVALID\", \"DEBUGGING\", \"TRACE\", \"FATAL\"])\n    def test_validate_config_invalid_logging_level(self, invalid_level):\n        \"\"\"Test validate_config with invalid logging level.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": invalid_level, \"file\": \"logs/app.log\"}\n        }\n    \n        with pytest.raises(ValueError, match=f\"Invalid logging level '{invalid_level}'\"):\n>           validate_config(config)\n\ntests\\unit\\test_config_manager.py:314: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'INVALID'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: analytics\n\nshared\\config\\config_manager.py:217: ConfigurationError\n__ TestValidateConfig.test_validate_config_invalid_logging_level[DEBUGGING] ___\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA1274E450>\ninvalid_level = 'DEBUGGING'\n\n    @pytest.mark.parametrize(\"invalid_level\", [\"INVALID\", \"DEBUGGING\", \"TRACE\", \"FATAL\"])\n    def test_validate_config_invalid_logging_level(self, invalid_level):\n        \"\"\"Test validate_config with invalid logging level.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": invalid_level, \"file\": \"logs/app.log\"}\n        }\n    \n        with pytest.raises(ValueError, match=f\"Invalid logging level '{invalid_level}'\"):\n>           validate_config(config)\n\ntests\\unit\\test_config_manager.py:314: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'DEBUGGING'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: analytics\n\nshared\\config\\config_manager.py:217: ConfigurationError\n____ TestValidateConfig.test_validate_config_invalid_logging_level[TRACE] _____\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA126233E0>\ninvalid_level = 'TRACE'\n\n    @pytest.mark.parametrize(\"invalid_level\", [\"INVALID\", \"DEBUGGING\", \"TRACE\", \"FATAL\"])\n    def test_validate_config_invalid_logging_level(self, invalid_level):\n        \"\"\"Test validate_config with invalid logging level.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": invalid_level, \"file\": \"logs/app.log\"}\n        }\n    \n        with pytest.raises(ValueError, match=f\"Invalid logging level '{invalid_level}'\"):\n>           validate_config(config)\n\ntests\\unit\\test_config_manager.py:314: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'TRACE'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: analytics\n\nshared\\config\\config_manager.py:217: ConfigurationError\n____ TestValidateConfig.test_validate_config_invalid_logging_level[FATAL] _____\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA126235C0>\ninvalid_level = 'FATAL'\n\n    @pytest.mark.parametrize(\"invalid_level\", [\"INVALID\", \"DEBUGGING\", \"TRACE\", \"FATAL\"])\n    def test_validate_config_invalid_logging_level(self, invalid_level):\n        \"\"\"Test validate_config with invalid logging level.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": invalid_level, \"file\": \"logs/app.log\"}\n        }\n    \n        with pytest.raises(ValueError, match=f\"Invalid logging level '{invalid_level}'\"):\n>           validate_config(config)\n\ntests\\unit\\test_config_manager.py:314: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'FATAL'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: analytics\n\nshared\\config\\config_manager.py:217: ConfigurationError\n_____ TestValidateConfig.test_validate_config_valid_logging_levels[DEBUG] _____\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA127A3690>\nvalid_level = 'DEBUG'\n\n    @pytest.mark.parametrize(\"valid_level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n    def test_validate_config_valid_logging_levels(self, valid_level):\n        \"\"\"Test validate_config with valid logging levels.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": valid_level, \"file\": \"logs/app.log\"}\n        }\n    \n        # Should not raise an exception\n>       validate_config(config)\n\ntests\\unit\\test_config_manager.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'DEBUG'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: analytics\n\nshared\\config\\config_manager.py:217: ConfigurationError\n_____ TestValidateConfig.test_validate_config_valid_logging_levels[INFO] ______\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA127A3930>\nvalid_level = 'INFO'\n\n    @pytest.mark.parametrize(\"valid_level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n    def test_validate_config_valid_logging_levels(self, valid_level):\n        \"\"\"Test validate_config with valid logging levels.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": valid_level, \"file\": \"logs/app.log\"}\n        }\n    \n        # Should not raise an exception\n>       validate_config(config)\n\ntests\\unit\\test_config_manager.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'INFO'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: analytics\n\nshared\\config\\config_manager.py:217: ConfigurationError\n____ TestValidateConfig.test_validate_config_valid_logging_levels[WARNING] ____\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA126DAB60>\nvalid_level = 'WARNING'\n\n    @pytest.mark.parametrize(\"valid_level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n    def test_validate_config_valid_logging_levels(self, valid_level):\n        \"\"\"Test validate_config with valid logging levels.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": valid_level, \"file\": \"logs/app.log\"}\n        }\n    \n        # Should not raise an exception\n>       validate_config(config)\n\ntests\\unit\\test_config_manager.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'WARNING'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: analytics\n\nshared\\config\\config_manager.py:217: ConfigurationError\n_____ TestValidateConfig.test_validate_config_valid_logging_levels[ERROR] _____\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA127AC110>\nvalid_level = 'ERROR'\n\n    @pytest.mark.parametrize(\"valid_level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n    def test_validate_config_valid_logging_levels(self, valid_level):\n        \"\"\"Test validate_config with valid logging levels.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": valid_level, \"file\": \"logs/app.log\"}\n        }\n    \n        # Should not raise an exception\n>       validate_config(config)\n\ntests\\unit\\test_config_manager.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'ERROR'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: analytics\n\nshared\\config\\config_manager.py:217: ConfigurationError\n___ TestValidateConfig.test_validate_config_valid_logging_levels[CRITICAL] ____\n\nself = <unit.test_config_manager.TestValidateConfig object at 0x000001AA127AC410>\nvalid_level = 'CRITICAL'\n\n    @pytest.mark.parametrize(\"valid_level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n    def test_validate_config_valid_logging_levels(self, valid_level):\n        \"\"\"Test validate_config with valid logging levels.\"\"\"\n        config = {\n            \"app\": {\"name\": \"test\", \"version\": \"1.0.0\"},\n            \"data_store\": {\"base_path\": \"./data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": True}},\n            \"logging\": {\"level\": valid_level, \"file\": \"logs/app.log\"}\n        }\n    \n        # Should not raise an exception\n>       validate_config(config)\n\ntests\\unit\\test_config_manager.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'test', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file': 'logs/app.log', 'level': 'CRITICAL'}, 'services': {'commit_tracker': {'enabled': True}}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n                raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\n    \n        # Validate data_store section\n        data_store = config['data_store']\n        if 'base_path' not in data_store:\n            raise ConfigurationError(\"data_store.base_path is required\")\n    \n        # Validate services section\n        services = config['services']\n        required_services = ['commit_tracker', 'analytics', 'notifications', 'api_gateway']\n    \n        for service in required_services:\n            if service not in services:\n>               raise ConfigurationError(f\"Missing service configuration: {service}\")\nE               shared.utils.error_handler.ConfigurationError: Missing service configuration: analytics\n\nshared\\config\\config_manager.py:217: ConfigurationError\n______________ TestUpdateConfig.test_update_config_simple_update ______________\n\nself = <unit.test_config_manager.TestUpdateConfig object at 0x000001AA12726C10>\nsample_config = {'app': {'name': 'CraftNudge AI Agent', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file'...'commit_tracker': {'batch_size': 100, 'enabled': True}, 'notifications': {'enabled': False, 'providers': ['console']}}}\n\n    def test_update_config_simple_update(self, sample_config):\n        \"\"\"Test update_config with simple update.\"\"\"\n        with patch('shared.config.config_manager.get_config', return_value=sample_config):\n            with patch('shared.config.config_manager._config_cache', {}):\n                update = {\"app\": {\"name\": \"Updated Name\"}}\n>               result = update_config(update)\n                         ^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_config_manager.py:406: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nshared\\config\\config_manager.py:284: in update_config\n    validate_config(_config_cache)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'Updated Name'}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n>               raise ConfigurationError(f\"Missing required configuration section: {section}\")\nE               shared.utils.error_handler.ConfigurationError: Missing required configuration section: data_store\n\nshared\\config\\config_manager.py:201: ConfigurationError\n__________ TestUpdateConfig.test_update_config_loads_if_cache_empty ___________\n\nself = <unit.test_config_manager.TestUpdateConfig object at 0x000001AA12726D50>\nsample_config = {'app': {'name': 'CraftNudge AI Agent', 'version': '1.0.0'}, 'data_store': {'base_path': './data'}, 'logging': {'file'...'commit_tracker': {'batch_size': 100, 'enabled': True}, 'notifications': {'enabled': False, 'providers': ['console']}}}\n\n    def test_update_config_loads_if_cache_empty(self, sample_config):\n        \"\"\"Test update_config loads config if cache is empty.\"\"\"\n        with patch('shared.config.config_manager.get_config', return_value=sample_config):\n            with patch('shared.config.config_manager._config_cache', {}):\n                update = {\"app\": {\"name\": \"Updated Name\"}}\n>               result = update_config(update)\n                         ^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_config_manager.py:416: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nshared\\config\\config_manager.py:284: in update_config\n    validate_config(_config_cache)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'app': {'name': 'Updated Name'}}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n>               raise ConfigurationError(f\"Missing required configuration section: {section}\")\nE               shared.utils.error_handler.ConfigurationError: Missing required configuration section: data_store\n\nshared\\config\\config_manager.py:201: ConfigurationError\n________ TestUpdateConfig.test_update_config_handles_validation_error _________\n\nself = <unit.test_config_manager.TestUpdateConfig object at 0x000001AA126EBA80>\n\n    def test_update_config_handles_validation_error(self):\n        \"\"\"Test update_config handles validation errors.\"\"\"\n        invalid_update = {\"app\": \"not_a_dict\"}\n    \n        with pytest.raises(ValueError):\n>           update_config(invalid_update)\n\ntests\\unit\\test_config_manager.py:425: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nshared\\config\\config_manager.py:284: in update_config\n    validate_config(_config_cache)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig = {'analytics': {'insights': {'insight_expiry_days': 30, 'max_insights_per_day': 5, 'personalized_recommendations': True...: {'max_message_length': 500, 'min_message_length': 3, 'require_author': True, 'require_commit_hash': True, ...}}, ...}\n\n    def validate_config(config: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate configuration structure and values.\n    \n        Args:\n            config: Configuration dictionary to validate\n    \n        Raises:\n            ConfigurationError: If configuration is invalid\n        \"\"\"\n        required_sections = ['app', 'data_store', 'services', 'logging']\n    \n        for section in required_sections:\n            if section not in config:\n                raise ConfigurationError(f\"Missing required configuration section: {section}\")\n    \n            if not isinstance(config[section], dict):\n>               raise ConfigurationError(f\"Configuration section '{section}' must be a dictionary\")\nE               shared.utils.error_handler.ConfigurationError: Configuration section 'app' must be a dictionary\n\nshared\\config\\config_manager.py:204: ConfigurationError\n___________ TestConfigManagerIntegration.test_full_config_lifecycle ___________\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_full_config_lifecycle0\\\\lifecycle_test.yaml'\n\n    def create_default_config(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Create a default configuration file.\n    \n        Args:\n            config_path: Path where to create the config file\n    \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        default_config = {\n            'app': {\n                'name': 'CraftNudge AI Agent',\n                'version': '1.0.0',\n                'environment': 'development'\n            },\n            'data_store': {\n                'base_path': './shared/data-store',\n                'behaviors': {\n                    'commits_file': 'commits.jsonl',\n                    'patterns_file': 'patterns.jsonl',\n                    'insights_file': 'insights.jsonl'\n                },\n                'analytics': {\n                    'metrics_file': 'metrics.jsonl',\n                    'trends_file': 'trends.jsonl'\n                },\n                'notifications': {\n                    'sent_file': 'sent.jsonl',\n                    'preferences_file': 'preferences.jsonl'\n                }\n            },\n            'services': {\n                'commit_tracker': {\n                    'enabled': True,\n                    'auto_track': False,\n                    'max_commits_per_run': 100\n                },\n                'analytics': {\n                    'enabled': True,\n                    'batch_size': 50,\n                    'processing_interval': 300\n                },\n                'notifications': {\n                    'enabled': False,\n                    'providers': ['console', 'email'],\n                    'email': {\n                        'smtp_server': 'localhost',\n                        'smtp_port': 587,\n                        'use_tls': True\n                    }\n                },\n                'api_gateway': {\n                    'enabled': True,\n                    'host': '0.0.0.0',\n                    'port': 8000,\n                    'cors_origins': ['http://localhost:3000']\n                }\n            },\n            'logging': {\n                'level': 'INFO',\n                'file': './logs/craftnudge.log',\n                'format': '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>',\n                'rotation': '10 MB',\n                'retention': '7 days'\n            },\n            'security': {\n                'api_key_required': False,\n                'rate_limiting': {\n                    'enabled': True,\n                    'requests_per_minute': 60\n                }\n            },\n            'performance': {\n                'max_workers': 4,\n                'timeout': 30,\n                'cache_ttl': 300\n            }\n        }\n    \n        try:\n>           config_path.parent.mkdir(parents=True, exist_ok=True)\n            ^^^^^^^^^^^^^^^^^^\nE           AttributeError: 'str' object has no attribute 'parent'\n\nshared\\config\\config_manager.py:175: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_config_manager.TestConfigManagerIntegration object at 0x000001AA12727110>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_full_config_lifecycle0')\n\n    def test_full_config_lifecycle(self, temp_dir):\n        \"\"\"Test full configuration lifecycle.\"\"\"\n        config_file = temp_dir / \"lifecycle_test.yaml\"\n    \n        # Create default config\n>       default_config = create_default_config(str(config_file))\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_config_manager.py:507: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconfig_path = 'C:\\\\Users\\\\MOHAMMAD ASIF\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-MOHAMMAD ASIF\\\\pytest-25\\\\test_full_config_lifecycle0\\\\lifecycle_test.yaml'\n\n    def create_default_config(config_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Create a default configuration file.\n    \n        Args:\n            config_path: Path where to create the config file\n    \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        default_config = {\n            'app': {\n                'name': 'CraftNudge AI Agent',\n                'version': '1.0.0',\n                'environment': 'development'\n            },\n            'data_store': {\n                'base_path': './shared/data-store',\n                'behaviors': {\n                    'commits_file': 'commits.jsonl',\n                    'patterns_file': 'patterns.jsonl',\n                    'insights_file': 'insights.jsonl'\n                },\n                'analytics': {\n                    'metrics_file': 'metrics.jsonl',\n                    'trends_file': 'trends.jsonl'\n                },\n                'notifications': {\n                    'sent_file': 'sent.jsonl',\n                    'preferences_file': 'preferences.jsonl'\n                }\n            },\n            'services': {\n                'commit_tracker': {\n                    'enabled': True,\n                    'auto_track': False,\n                    'max_commits_per_run': 100\n                },\n                'analytics': {\n                    'enabled': True,\n                    'batch_size': 50,\n                    'processing_interval': 300\n                },\n                'notifications': {\n                    'enabled': False,\n                    'providers': ['console', 'email'],\n                    'email': {\n                        'smtp_server': 'localhost',\n                        'smtp_port': 587,\n                        'use_tls': True\n                    }\n                },\n                'api_gateway': {\n                    'enabled': True,\n                    'host': '0.0.0.0',\n                    'port': 8000,\n                    'cors_origins': ['http://localhost:3000']\n                }\n            },\n            'logging': {\n                'level': 'INFO',\n                'file': './logs/craftnudge.log',\n                'format': '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>',\n                'rotation': '10 MB',\n                'retention': '7 days'\n            },\n            'security': {\n                'api_key_required': False,\n                'rate_limiting': {\n                    'enabled': True,\n                    'requests_per_minute': 60\n                }\n            },\n            'performance': {\n                'max_workers': 4,\n                'timeout': 30,\n                'cache_ttl': 300\n            }\n        }\n    \n        try:\n            config_path.parent.mkdir(parents=True, exist_ok=True)\n    \n            with open(config_path, 'w', encoding='utf-8') as file:\n                yaml.dump(default_config, file, default_flow_style=False, indent=2)\n    \n            logger.info(f\"Default configuration created at {config_path}\")\n            return default_config\n    \n        except Exception as e:\n>           raise ConfigurationError(f\"Failed to create default configuration: {e}\")\nE           shared.utils.error_handler.ConfigurationError: Failed to create default configuration: 'str' object has no attribute 'parent'\n\nshared\\config\\config_manager.py:184: ConfigurationError\n___________ TestConfigManagerIntegration.test_config_with_real_file ___________\n\nself = <unit.test_config_manager.TestConfigManagerIntegration object at 0x000001AA12727250>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_config_with_real_file0')\n\n    def test_config_with_real_file(self, temp_dir):\n        \"\"\"Test configuration with real file operations.\"\"\"\n        config_file = temp_dir / \"real_config.yaml\"\n    \n        # Create a custom config\n        custom_config = {\n            \"app\": {\"name\": \"Custom App\", \"version\": \"2.0.0\"},\n            \"data_store\": {\"base_path\": \"/custom/data\"},\n            \"services\": {\"commit_tracker\": {\"enabled\": False}},\n            \"logging\": {\"level\": \"DEBUG\", \"file\": \"/custom/logs/app.log\"}\n        }\n    \n        # Write config to file\n        with open(config_file, 'w') as f:\n            yaml.dump(custom_config, f)\n    \n        # Load and validate\n        loaded_config = get_config(str(config_file))\n>       assert loaded_config == custom_config\nE       AssertionError: assert {'analytics':...e, ...}}, ...} == {'app': {'nam...led': False}}}\nE         \nE         Differing items:\nE         {'logging': {'file': {'enabled': True, 'max_size': '10MB', 'path': 'logs/craftnudge.log', 'retention': '30 days', ...}...: 'INFO', 'services': {'analytics': 'INFO', 'api_gateway': 'INFO', 'commit_tracker': 'INFO', 'notifications': 'INFO'}}} != {'logging': {'file': '/custom/logs/app.log', 'level': 'DEBUG'}}\nE         {'app': 'not_a_dict'} != {'app': {'name': 'Custom App', 'version': '2.0.0'}}\nE         {'data_store': {'analytics': {'metrics_file': 'analytics/metrics.jsonl', 'trends_file': 'analytics/trends.jsonl'}, 'ba...'}, 'notifications': {'preferences_file': 'notifications...\nE         \nE         ...Full output truncated (70 lines hidden), use '-vv' to show\n\ntests\\unit\\test_config_manager.py:546: AssertionError\n____________ TestDataWriter.test_ensure_data_store_exists_success _____________\n\nself = <unit.test_data_writer.TestDataWriter object at 0x000001AA12818DC0>\nmock_logger = <MagicMock name='logger' id='1829970766080'>\nmock_mkdir = <MagicMock name='mkdir' id='1829970762384'>\nmock_get_config = <MagicMock name='get_config' id='1829970764064'>\n\n    @patch('services.commit_tracker_service.src.data_writer.get_config')\n    @patch('pathlib.Path.mkdir')\n    @patch('services.commit_tracker_service.src.data_writer.logger')\n    def test_ensure_data_store_exists_success(self, mock_logger, mock_mkdir, mock_get_config):\n        \"\"\"Test _ensure_data_store_exists with successful execution.\"\"\"\n        mock_get_config.return_value = self.mock_config\n    \n        data_writer = DataWriter()\n        data_writer._ensure_data_store_exists()\n    \n>       mock_mkdir.assert_called_once_with(parents=True, exist_ok=True)\n\ntests\\unit\\test_data_writer.py:613: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <MagicMock name='mkdir' id='1829970762384'>, args = ()\nkwargs = {'exist_ok': True, 'parents': True}\nmsg = \"Expected 'mkdir' to be called once. Called 2 times.\\nCalls: [call(parents=True, exist_ok=True), call(parents=True, exist_ok=True)].\"\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n>           raise AssertionError(msg)\nE           AssertionError: Expected 'mkdir' to be called once. Called 2 times.\nE           Calls: [call(parents=True, exist_ok=True), call(parents=True, exist_ok=True)].\n\nC:\\Python313\\Lib\\unittest\\mock.py:990: AssertionError\n_____________ TestDataWriter.test_ensure_data_store_exists_error ______________\n\nself = <unit.test_data_writer.TestDataWriter object at 0x000001AA12818E60>\nmock_logger = <MagicMock name='logger' id='1829968456608'>\nmock_mkdir = <MagicMock name='mkdir' id='1829970760704'>\nmock_get_config = <MagicMock name='get_config' id='1829970757680'>\n\n    @patch('services.commit_tracker_service.src.data_writer.get_config')\n    @patch('pathlib.Path.mkdir')\n    @patch('services.commit_tracker_service.src.data_writer.logger')\n    def test_ensure_data_store_exists_error(self, mock_logger, mock_mkdir, mock_get_config):\n        \"\"\"Test _ensure_data_store_exists handles errors.\"\"\"\n        mock_get_config.return_value = self.mock_config\n        mock_mkdir.side_effect = Exception(\"Permission denied\")\n    \n>       data_writer = DataWriter()\n                      ^^^^^^^^^^^^\n\ntests\\unit\\test_data_writer.py:624: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nservices\\commit_tracker_service\\src\\data_writer.py:44: in __init__\n    self._ensure_data_store_exists()\nservices\\commit_tracker_service\\src\\data_writer.py:293: in _ensure_data_store_exists\n    behaviors_dir.mkdir(parents=True, exist_ok=True)\nC:\\Python313\\Lib\\unittest\\mock.py:1169: in __call__\n    return self._mock_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Python313\\Lib\\unittest\\mock.py:1173: in _mock_call\n    return self._execute_mock_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <MagicMock name='mkdir' id='1829970760704'>, args = ()\nkwargs = {'exist_ok': True, 'parents': True}\neffect = Exception('Permission denied')\n\n    def _execute_mock_call(self, /, *args, **kwargs):\n        # separate from _increment_mock_call so that awaited functions are\n        # executed separately from their call, also AsyncMock overrides this method\n    \n        effect = self.side_effect\n        if effect is not None:\n            if _is_exception(effect):\n>               raise effect\nE               Exception: Permission denied\n\nC:\\Python313\\Lib\\unittest\\mock.py:1228: Exception\n__________ TestCraftNudgeError.test_craft_nudge_error_initialization __________\n\nself = <unit.test_error_handler.TestCraftNudgeError object at 0x000001AA12725E50>\n\n    def test_craft_nudge_error_initialization(self):\n        \"\"\"Test CraftNudgeError initialization with message.\"\"\"\n        error = CraftNudgeError(\"Test error message\")\n        assert str(error) == \"Test error message\"\n        assert error.message == \"Test error message\"\n        assert error.error_code is None\n>       assert error.details is None\nE       AssertionError: assert {} is None\nE        +  where {} = CraftNudgeError('Test error message').details\n\ntests\\unit\\test_error_handler.py:39: AssertionError\n________ TestCraftNudgeError.test_craft_nudge_error_default_parameters ________\n\nself = <unit.test_error_handler.TestCraftNudgeError object at 0x000001AA12850050>\n\n    def test_craft_nudge_error_default_parameters(self):\n        \"\"\"Test CraftNudgeError with default parameters.\"\"\"\n>       error = CraftNudgeError()\n                ^^^^^^^^^^^^^^^^^\nE       TypeError: CraftNudgeError.__init__() missing 1 required positional argument: 'message'\n\ntests\\unit\\test_error_handler.py:44: TypeError\n_________ TestCraftNudgeError.test_craft_nudge_error_timestamp_format _________\n\nself = <unit.test_error_handler.TestCraftNudgeError object at 0x000001AA128048A0>\n\n    def test_craft_nudge_error_timestamp_format(self):\n        \"\"\"Test that CraftNudgeError timestamp is properly formatted.\"\"\"\n        error = CraftNudgeError(\"Test\")\n>       assert isinstance(error.timestamp, datetime)\nE       AssertionError: assert False\nE        +  where False = isinstance('2025-08-17T10:57:41.635163+00:00', datetime)\nE        +    where '2025-08-17T10:57:41.635163+00:00' = CraftNudgeError('Test').timestamp\n\ntests\\unit\\test_error_handler.py:53: AssertionError\n______________ TestHandleError.test_handle_error_basic_exception ______________\n\nself = <unit.test_error_handler.TestHandleError object at 0x000001AA12850410>\nmock_logger = <MagicMock id='1829970106352'>\n\n    def test_handle_error_basic_exception(self, mock_logger):\n        \"\"\"Test handle_error with basic exception.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            exception = ValueError(\"Test value error\")\n>           result = handle_error(exception)\n                     ^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: handle_error() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:117: TypeError\n______________ TestHandleError.test_handle_error_with_error_code ______________\n\nself = <unit.test_error_handler.TestHandleError object at 0x000001AA12850550>\nmock_logger = <MagicMock id='1829970112400'>\n\n    def test_handle_error_with_error_code(self, mock_logger):\n        \"\"\"Test handle_error with error code.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            exception = CraftNudgeError(\"Test error\", error_code=\"TEST_001\")\n>           result = handle_error(exception)\n                     ^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: handle_error() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:127: TypeError\n_______________ TestHandleError.test_handle_error_with_details ________________\n\nself = <unit.test_error_handler.TestHandleError object at 0x000001AA12804D60>\nmock_logger = <MagicMock id='1829970109040'>\n\n    def test_handle_error_with_details(self, mock_logger):\n        \"\"\"Test handle_error with additional details.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            details = {\"field\": \"test_field\", \"value\": \"test_value\"}\n            exception = CraftNudgeError(\"Test error\", details=details)\n>           result = handle_error(exception)\n                     ^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: handle_error() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:138: TypeError\n_____________ TestHandleError.test_handle_error_craft_nudge_error _____________\n\nself = <unit.test_error_handler.TestHandleError object at 0x000001AA12804E90>\nmock_logger = <MagicMock id='1829970101648'>\n\n    def test_handle_error_craft_nudge_error(self, mock_logger):\n        \"\"\"Test handle_error with CraftNudgeError.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            exception = CraftNudgeError(\"Custom error message\")\n>           result = handle_error(exception)\n                     ^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: handle_error() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:147: TypeError\n_____________ TestHandleError.test_handle_error_timestamp_format ______________\n\nself = <unit.test_error_handler.TestHandleError object at 0x000001AA12855A30>\nmock_logger = <MagicMock id='1829968458960'>\n\n    def test_handle_error_timestamp_format(self, mock_logger):\n        \"\"\"Test that handle_error includes timestamp.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            exception = ValueError(\"Test error\")\n>           result = handle_error(exception)\n                     ^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: handle_error() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:157: TypeError\n____________ TestHandleError.test_handle_error_traceback_included _____________\n\nself = <unit.test_error_handler.TestHandleError object at 0x000001AA126F7130>\nmock_logger = <MagicMock id='1829968449216'>\n\n    def test_handle_error_traceback_included(self, mock_logger):\n        \"\"\"Test that handle_error includes traceback information.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            exception = ValueError(\"Test error\")\n>           result = handle_error(exception)\n                     ^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: handle_error() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:167: TypeError\n______ TestValidateRequiredFields.test_validate_required_fields_success _______\n\nself = <unit.test_error_handler.TestValidateRequiredFields object at 0x000001AA12850690>\n\n    def test_validate_required_fields_success(self):\n        \"\"\"Test validate_required_fields with valid data.\"\"\"\n        data = {\"name\": \"test\", \"value\": 123, \"enabled\": True}\n        required_fields = [\"name\", \"value\"]\n    \n        # Should not raise an exception\n>       validate_required_fields(data, required_fields)\nE       TypeError: validate_required_fields() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:182: TypeError\n___ TestValidateRequiredFields.test_validate_required_fields_missing_field ____\n\nself = <unit.test_error_handler.TestValidateRequiredFields object at 0x000001AA128507D0>\n\n    def test_validate_required_fields_missing_field(self):\n        \"\"\"Test validate_required_fields with missing field.\"\"\"\n        data = {\"name\": \"test\", \"value\": 123}\n        required_fields = [\"name\", \"value\", \"missing_field\"]\n    \n        with pytest.raises(ValidationError) as exc_info:\n>           validate_required_fields(data, required_fields)\nE           TypeError: validate_required_fields() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:190: TypeError\n_____ TestValidateRequiredFields.test_validate_required_fields_none_value _____\n\nself = <unit.test_error_handler.TestValidateRequiredFields object at 0x000001AA12804FC0>\n\n    def test_validate_required_fields_none_value(self):\n        \"\"\"Test validate_required_fields with None value.\"\"\"\n        data = {\"name\": None, \"value\": 123}\n        required_fields = [\"name\", \"value\"]\n    \n        with pytest.raises(ValidationError) as exc_info:\n>           validate_required_fields(data, required_fields)\nE           TypeError: validate_required_fields() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:200: TypeError\n_____ TestValidateRequiredFields.test_validate_required_fields_empty_data _____\n\nself = <unit.test_error_handler.TestValidateRequiredFields object at 0x000001AA128050F0>\n\n    def test_validate_required_fields_empty_data(self):\n        \"\"\"Test validate_required_fields with empty data.\"\"\"\n        data = {}\n        required_fields = [\"name\", \"value\"]\n    \n        with pytest.raises(ValidationError) as exc_info:\n>           validate_required_fields(data, required_fields)\nE           TypeError: validate_required_fields() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:210: TypeError\n_ TestValidateRequiredFields.test_validate_required_fields_empty_required_list _\n\nself = <unit.test_error_handler.TestValidateRequiredFields object at 0x000001AA128568D0>\n\n    def test_validate_required_fields_empty_required_list(self):\n        \"\"\"Test validate_required_fields with empty required list.\"\"\"\n        data = {\"name\": \"test\", \"value\": 123}\n        required_fields = []\n    \n        # Should not raise an exception\n>       validate_required_fields(data, required_fields)\nE       TypeError: validate_required_fields() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:220: TypeError\n__ TestValidateRequiredFields.test_validate_required_fields_context_in_error __\n\nself = <unit.test_error_handler.TestValidateRequiredFields object at 0x000001AA126F7460>\n\n    def test_validate_required_fields_context_in_error(self):\n        \"\"\"Test that ValidationError includes context information.\"\"\"\n        data = {\"name\": \"test\"}\n        required_fields = [\"name\", \"missing_field\"]\n    \n        with pytest.raises(ValidationError) as exc_info:\n>           validate_required_fields(data, required_fields)\nE           TypeError: validate_required_fields() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:228: TypeError\n___________ TestValidateFieldType.test_validate_field_type_success ____________\n\nself = <unit.test_error_handler.TestValidateFieldType object at 0x000001AA12850910>\n\n    def test_validate_field_type_success(self):\n        \"\"\"Test validate_field_type with correct type.\"\"\"\n        data = {\"name\": \"test\", \"value\": 123, \"enabled\": True}\n    \n>       validate_field_type(data, \"name\", str)\nE       TypeError: validate_field_type() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:242: TypeError\n________ TestValidateFieldType.test_validate_field_type_missing_field _________\n\nself = <unit.test_error_handler.TestValidateFieldType object at 0x000001AA12850A50>\n\n    def test_validate_field_type_missing_field(self):\n        \"\"\"Test validate_field_type with missing field.\"\"\"\n        data = {\"name\": \"test\"}\n    \n        with pytest.raises(ValidationError) as exc_info:\n>           validate_field_type(data, \"missing_field\", str)\nE           TypeError: validate_field_type() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:251: TypeError\n__________ TestValidateFieldType.test_validate_field_type_wrong_type __________\n\nself = <unit.test_error_handler.TestValidateFieldType object at 0x000001AA12805220>\n\n    def test_validate_field_type_wrong_type(self):\n        \"\"\"Test validate_field_type with wrong type.\"\"\"\n        data = {\"name\": \"test\", \"value\": \"not_an_int\"}\n    \n        with pytest.raises(ValidationError) as exc_info:\n>           validate_field_type(data, \"value\", int)\nE           TypeError: validate_field_type() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:260: TypeError\n________ TestValidateFieldType.test_validate_field_type_complex_types _________\n\nself = <unit.test_error_handler.TestValidateFieldType object at 0x000001AA12805350>\n\n    def test_validate_field_type_complex_types(self):\n        \"\"\"Test validate_field_type with complex types.\"\"\"\n        data = {\n            \"list_field\": [1, 2, 3],\n            \"dict_field\": {\"key\": \"value\"},\n            \"tuple_field\": (1, 2, 3)\n        }\n    \n>       validate_field_type(data, \"list_field\", list)\nE       TypeError: validate_field_type() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:272: TypeError\n__________ TestValidateFieldType.test_validate_field_type_none_value __________\n\nself = <unit.test_error_handler.TestValidateFieldType object at 0x000001AA12857770>\n\n    def test_validate_field_type_none_value(self):\n        \"\"\"Test validate_field_type with None value.\"\"\"\n        data = {\"name\": None}\n    \n        with pytest.raises(ValidationError) as exc_info:\n>           validate_field_type(data, \"name\", str)\nE           TypeError: validate_field_type() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:281: TypeError\n_______ TestValidateFieldType.test_validate_field_type_context_in_error _______\n\nself = <unit.test_error_handler.TestValidateFieldType object at 0x000001AA126F7570>\n\n    def test_validate_field_type_context_in_error(self):\n        \"\"\"Test that ValidationError includes context information.\"\"\"\n        data = {\"value\": \"not_an_int\"}\n    \n        with pytest.raises(ValidationError) as exc_info:\n>           validate_field_type(data, \"value\", int)\nE           TypeError: validate_field_type() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:290: TypeError\n__________________ TestSafeExecute.test_safe_execute_success __________________\n\nself = <unit.test_error_handler.TestSafeExecute object at 0x000001AA12850B90>\nmock_logger = <MagicMock id='1829970104000'>\n\n    def test_safe_execute_success(self, mock_logger):\n        \"\"\"Test safe_execute with successful function.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def test_func():\n                return \"success\"\n    \n            result = safe_execute(test_func)\n>           assert result == \"success\"\nE           AssertionError: assert {'result': 'success', 'status': 'success'} == 'success'\n\ntests\\unit\\test_error_handler.py:307: AssertionError\n________________ TestSafeExecute.test_safe_execute_with_kwargs ________________\n\nself = <unit.test_error_handler.TestSafeExecute object at 0x000001AA12850CD0>\nmock_logger = <MagicMock id='1829970115760'>\n\n    def test_safe_execute_with_kwargs(self, mock_logger):\n        \"\"\"Test safe_execute with keyword arguments.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def test_func(name, value=0):\n                return f\"{name}: {value}\"\n    \n            result = safe_execute(test_func, name=\"test\", value=123)\n>           assert result == \"test: 123\"\nE           AssertionError: assert {'result': 'test: 123', 'status': 'success'} == 'test: 123'\n\ntests\\unit\\test_error_handler.py:317: AssertionError\n_____________ TestSafeExecute.test_safe_execute_function_failure ______________\n\nself = <unit.test_error_handler.TestSafeExecute object at 0x000001AA12805480>\nmock_logger = <MagicMock id='1829970759024'>\n\n    def test_safe_execute_function_failure(self, mock_logger):\n        \"\"\"Test safe_execute with function that raises exception.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def test_func():\n                raise ValueError(\"Test error\")\n    \n            result = safe_execute(test_func)\n>           assert result is None\nE           AssertionError: assert {'context': 'safe_execute(test_func)', 'error': 'Test error', 'error_type': 'ValueError', 'status': 'error', ...} is None\n\ntests\\unit\\test_error_handler.py:327: AssertionError\n---------------------------- Captured stderr call -----------------------------\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in safe_execute(test_func): Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in safe_execute(test_func): Test error\u001b[0m\n_________ TestSafeExecute.test_safe_execute_with_complex_return_value _________\n\nself = <unit.test_error_handler.TestSafeExecute object at 0x000001AA128055B0>\nmock_logger = <MagicMock id='1829970768432'>\n\n    def test_safe_execute_with_complex_return_value(self, mock_logger):\n        \"\"\"Test safe_execute with complex return value.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def test_func():\n                return {\"status\": \"success\", \"data\": [1, 2, 3]}\n    \n            result = safe_execute(test_func)\n>           assert result == {\"status\": \"success\", \"data\": [1, 2, 3]}\nE           AssertionError: assert {'result': {'...s': 'success'} == {'data': [1, ...s': 'success'}\nE             \nE             Omitting 1 identical items, use -vv to show\nE             Left contains 1 more item:\nE             {'result': {'data': [1, 2, 3], 'status': 'success'}}\nE             Right contains 1 more item:\nE             {'data': [1, 2, 3]}\nE             Use -v to get more diff\n\ntests\\unit\\test_error_handler.py:337: AssertionError\n_________ TestSafeExecute.test_safe_execute_function_name_in_context __________\n\nself = <unit.test_error_handler.TestSafeExecute object at 0x000001AA128570B0>\nmock_logger = <MagicMock id='1829970764736'>\n\n    def test_safe_execute_function_name_in_context(self, mock_logger):\n        \"\"\"Test that function name is included in error context.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def test_func():\n                raise ValueError(\"Test error\")\n    \n            safe_execute(test_func)\n>           mock_logger.error.assert_called()\n\ntests\\unit\\test_error_handler.py:347: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <MagicMock name='mock.error' id='1829970759696'>\n\n    def assert_called(self):\n        \"\"\"assert that the mock was called at least once\n        \"\"\"\n        if self.call_count == 0:\n            msg = (\"Expected '%s' to have been called.\" %\n                   (self._mock_name or 'mock'))\n>           raise AssertionError(msg)\nE           AssertionError: Expected 'error' to have been called.\n\nC:\\Python313\\Lib\\unittest\\mock.py:948: AssertionError\n---------------------------- Captured stderr call -----------------------------\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in safe_execute(test_func): Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in safe_execute(test_func): Test error\u001b[0m\n_________ TestRetryOnError.test_retry_on_error_success_first_attempt __________\n\nself = <unit.test_error_handler.TestRetryOnError object at 0x000001AA12850E10>\nmock_logger = <MagicMock id='1829970758352'>\n\n    def test_retry_on_error_success_first_attempt(self, mock_logger):\n        \"\"\"Test retry_on_error with success on first attempt.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def test_func():\n                return \"success\"\n    \n            result = retry_on_error(test_func)\n>           assert result == \"success\"\nE           AssertionError: assert {'attempts': 1, 'result': 'success', 'status': 'success'} == 'success'\n\ntests\\unit\\test_error_handler.py:363: AssertionError\n_________ TestRetryOnError.test_retry_on_error_success_after_retries __________\n\nself = <unit.test_error_handler.TestRetryOnError object at 0x000001AA12850F50>\nmock_logger = <MagicMock id='1829970108704'>\n\n    def test_retry_on_error_success_after_retries(self, mock_logger):\n        \"\"\"Test retry_on_error with success after some retries.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            call_count = 0\n    \n            def test_func():\n                nonlocal call_count\n                call_count += 1\n                if call_count < 3:\n                    raise ValueError(\"Temporary error\")\n                return \"success\"\n    \n            result = retry_on_error(test_func, max_retries=5, delay=0.1)\n>           assert result == \"success\"\nE           AssertionError: assert {'attempts': 3, 'result': 'success', 'status': 'success'} == 'success'\n\ntests\\unit\\test_error_handler.py:379: AssertionError\n---------------------------- Captured stderr call -----------------------------\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Temporary error\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Temporary error\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.1 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.1 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 2 failed: Temporary error\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 2 failed: Temporary error\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.2 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.2 seconds...\u001b[0m\n___________ TestRetryOnError.test_retry_on_error_all_attempts_fail ____________\n\nself = <unit.test_error_handler.TestRetryOnError object at 0x000001AA128056E0>\nmock_logger = <MagicMock id='1829970103664'>\n\n    def test_retry_on_error_all_attempts_fail(self, mock_logger):\n        \"\"\"Test retry_on_error with all attempts failing.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def test_func():\n                raise ValueError(\"Persistent error\")\n    \n            result = retry_on_error(test_func, max_retries=3, delay=0.1)\n>           assert result is None\nE           AssertionError: assert {'context': 'retry_on_error(test_func)', 'details': {'attempts': 4, 'max_retries': 3}, 'error': 'Persistent error', 'error_code': 'MAX_RETRIES_EXCEEDED', ...} is None\n\ntests\\unit\\test_error_handler.py:389: AssertionError\n---------------------------- Captured stderr call -----------------------------\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Persistent error\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Persistent error\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.1 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.1 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 2 failed: Persistent error\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 2 failed: Persistent error\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.2 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:42\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.2 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 3 failed: Persistent error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 3 failed: Persistent error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.4 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.4 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 4 failed: Persistent error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 4 failed: Persistent error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m214\u001b[0m - \u001b[31m\u001b[1mAll 4 attempts failed\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m214\u001b[0m - \u001b[31m\u001b[1mAll 4 attempts failed\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in retry_on_error(test_func): Persistent error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in retry_on_error(test_func): Persistent error\u001b[0m\n___________ TestRetryOnError.test_retry_on_error_custom_parameters ____________\n\nself = <unit.test_error_handler.TestRetryOnError object at 0x000001AA12805810>\nmock_logger = <MagicMock id='1829970104336'>\n\n    def test_retry_on_error_custom_parameters(self, mock_logger):\n        \"\"\"Test retry_on_error with custom retry parameters.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            call_count = 0\n    \n            def test_func():\n                nonlocal call_count\n                call_count += 1\n                if call_count < 2:\n                    raise ValueError(\"Temporary error\")\n                return \"success\"\n    \n            result = retry_on_error(test_func, max_retries=1, delay=0.1)\n>           assert result == \"success\"\nE           AssertionError: assert {'attempts': 2, 'result': 'success', 'status': 'success'} == 'success'\n\ntests\\unit\\test_error_handler.py:405: AssertionError\n---------------------------- Captured stderr call -----------------------------\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Temporary error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Temporary error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.1 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.1 seconds...\u001b[0m\n____________ TestRetryOnError.test_retry_on_error_with_args_kwargs ____________\n\nself = <unit.test_error_handler.TestRetryOnError object at 0x000001AA128555B0>\nmock_logger = <MagicMock id='1829968453584'>\n\n    def test_retry_on_error_with_args_kwargs(self, mock_logger):\n        \"\"\"Test retry_on_error with arguments and keyword arguments.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def test_func(name, value=0):\n                return f\"{name}: {value}\"\n    \n>           result = retry_on_error(test_func, \"test\", value=123)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_error_handler.py:414: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfunc = <function TestRetryOnError.test_retry_on_error_with_args_kwargs.<locals>.test_func at 0x000001AA12DC4220>\nmax_retries = 'test', delay = 1.0, backoff_factor = 2.0, args = ()\nkwargs = {'value': 123}, time = <module 'time' (built-in)>, last_error = None\ncurrent_delay = 1.0\n\n    def retry_on_error(\n        func,\n        max_retries: int = 3,\n        delay: float = 1.0,\n        backoff_factor: float = 2.0,\n        *args,\n        **kwargs\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Execute a function with retry logic on failure.\n    \n        Args:\n            func: Function to execute\n            max_retries: Maximum number of retry attempts\n            delay: Initial delay between retries in seconds\n            backoff_factor: Multiplier for delay on each retry\n            *args: Function arguments\n            **kwargs: Function keyword arguments\n    \n        Returns:\n            Dict containing either success result or error information\n        \"\"\"\n        import time\n    \n        last_error = None\n        current_delay = delay\n    \n>       for attempt in range(max_retries + 1):\n                             ^^^^^^^^^^^^^^^\nE       TypeError: can only concatenate str (not \"int\") to str\n\nshared\\utils\\error_handler.py:197: TypeError\n________________ TestRetryOnError.test_retry_on_error_logging _________________\n\nself = <unit.test_error_handler.TestRetryOnError object at 0x000001AA126F7680>\nmock_logger = <MagicMock id='1829968449552'>\n\n    def test_retry_on_error_logging(self, mock_logger):\n        \"\"\"Test that retry_on_error logs retry attempts.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def test_func():\n                raise ValueError(\"Test error\")\n    \n            retry_on_error(test_func, max_retries=2, delay=0.1)\n>           mock_logger.error.assert_called()\n\ntests\\unit\\test_error_handler.py:425: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <MagicMock name='mock.error' id='1829970764736'>\n\n    def assert_called(self):\n        \"\"\"assert that the mock was called at least once\n        \"\"\"\n        if self.call_count == 0:\n            msg = (\"Expected '%s' to have been called.\" %\n                   (self._mock_name or 'mock'))\n>           raise AssertionError(msg)\nE           AssertionError: Expected 'error' to have been called.\n\nC:\\Python313\\Lib\\unittest\\mock.py:948: AssertionError\n---------------------------- Captured stderr call -----------------------------\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.1 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.1 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 2 failed: Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 2 failed: Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.2 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.2 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 3 failed: Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 3 failed: Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m214\u001b[0m - \u001b[31m\u001b[1mAll 3 attempts failed\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m214\u001b[0m - \u001b[31m\u001b[1mAll 3 attempts failed\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in retry_on_error(test_func): Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:43\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in retry_on_error(test_func): Test error\u001b[0m\n______________ TestRetryOnError.test_retry_on_error_zero_retries ______________\n\nself = <unit.test_error_handler.TestRetryOnError object at 0x000001AA126F7790>\nmock_logger = <MagicMock id='1829970761712'>\n\n    def test_retry_on_error_zero_retries(self, mock_logger):\n        \"\"\"Test retry_on_error with zero retries.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def test_func():\n                raise ValueError(\"Test error\")\n    \n            result = retry_on_error(test_func, max_retries=0)\n>           assert result is None\nE           AssertionError: assert {'context': 'retry_on_error(test_func)', 'details': {'attempts': 1, 'max_retries': 0}, 'error': 'Test error', 'error_code': 'MAX_RETRIES_EXCEEDED', ...} is None\n\ntests\\unit\\test_error_handler.py:434: AssertionError\n---------------------------- Captured stderr call -----------------------------\n\u001b[32m2025-08-17 16:27:44\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:44\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:44\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m214\u001b[0m - \u001b[31m\u001b[1mAll 1 attempts failed\u001b[0m\n\u001b[32m2025-08-17 16:27:44\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m214\u001b[0m - \u001b[31m\u001b[1mAll 1 attempts failed\u001b[0m\n\u001b[32m2025-08-17 16:27:44\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in retry_on_error(test_func): Test error\u001b[0m\n\u001b[32m2025-08-17 16:27:44\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in retry_on_error(test_func): Test error\u001b[0m\n________ TestErrorHandlerIntegration.test_error_chain_with_validation _________\n\nself = <unit.test_error_handler.TestErrorHandlerIntegration object at 0x000001AA12851090>\nmock_logger = <MagicMock id='1829970768096'>\n\n    def test_error_chain_with_validation(self, mock_logger):\n        \"\"\"Test error handling chain with validation.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            data = {\"name\": \"test\"}\n    \n            # This should work without error\n>           validate_required_fields(data, [\"name\"])\nE           TypeError: validate_required_fields() missing 1 required positional argument: 'context'\n\ntests\\unit\\test_error_handler.py:463: TypeError\n________ TestErrorHandlerIntegration.test_safe_execute_with_validation ________\n\nself = <unit.test_error_handler.TestErrorHandlerIntegration object at 0x000001AA128511D0>\nmock_logger = <MagicMock id='1829970756672'>\n\n    def test_safe_execute_with_validation(self, mock_logger):\n        \"\"\"Test safe_execute with validation functions.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            def validate_data(data):\n                validate_required_fields(data, [\"name\"])\n                return True\n    \n            # Should succeed\n            result = safe_execute(validate_data, {\"name\": \"test\"})\n>           assert result is True\nE           assert {'context': 'safe_execute(validate_data)', 'error': \"validate_required_fields() missing 1 required positional argument: 'context'\", 'error_type': 'TypeError', 'status': 'error', ...} is True\n\ntests\\unit\\test_error_handler.py:478: AssertionError\n---------------------------- Captured stderr call -----------------------------\n\u001b[32m2025-08-17 16:27:47\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in safe_execute(validate_data): validate_required_fields() missing 1 required positional argument: 'context'\u001b[0m\n\u001b[32m2025-08-17 16:27:47\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in safe_execute(validate_data): validate_required_fields() missing 1 required positional argument: 'context'\u001b[0m\n______ TestErrorHandlerIntegration.test_retry_on_error_with_safe_execute ______\n\nself = <unit.test_error_handler.TestErrorHandlerIntegration object at 0x000001AA12805940>\nmock_logger = <MagicMock id='1829972904656'>\n\n    def test_retry_on_error_with_safe_execute(self, mock_logger):\n        \"\"\"Test retry_on_error with safe_execute.\"\"\"\n        with patch('shared.utils.error_handler.get_logger', return_value=mock_logger):\n            call_count = 0\n    \n            def unreliable_func():\n                nonlocal call_count\n                call_count += 1\n                if call_count < 3:\n                    raise ValueError(\"Temporary error\")\n                return \"success\"\n    \n            result = retry_on_error(unreliable_func, max_retries=5, delay=0.1)\n>           assert result == \"success\"\nE           AssertionError: assert {'attempts': 3, 'result': 'success', 'status': 'success'} == 'success'\n\ntests\\unit\\test_error_handler.py:497: AssertionError\n---------------------------- Captured stderr call -----------------------------\n\u001b[32m2025-08-17 16:27:47\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Temporary error\u001b[0m\n\u001b[32m2025-08-17 16:27:47\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 1 failed: Temporary error\u001b[0m\n\u001b[32m2025-08-17 16:27:47\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.1 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:47\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.1 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:47\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 2 failed: Temporary error\u001b[0m\n\u001b[32m2025-08-17 16:27:47\u001b[0m | \u001b[33m\u001b[1mWARNING \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m207\u001b[0m - \u001b[33m\u001b[1mAttempt 2 failed: Temporary error\u001b[0m\n\u001b[32m2025-08-17 16:27:47\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.2 seconds...\u001b[0m\n\u001b[32m2025-08-17 16:27:47\u001b[0m | \u001b[1mINFO    \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mretry_on_error\u001b[0m:\u001b[36m210\u001b[0m - \u001b[1mRetrying in 0.2 seconds...\u001b[0m\n_________________ TestExamplesInit.test_docstring_formatting __________________\n\nself = <unit.test_examples_init.TestExamplesInit object at 0x000001AA128516D0>\n\n    def test_docstring_formatting(self):\n        \"\"\"Test that the docstring is properly formatted.\"\"\"\n        import examples\n    \n        docstring = examples.__doc__\n    \n        # Should contain proper formatting\n>       assert docstring.strip().startswith('\"\"\"')\nE       assert False\nE        +  where False = <built-in method startswith of str object at 0x000001AA12BCE500>('\"\"\"')\nE        +    where <built-in method startswith of str object at 0x000001AA12BCE500> = 'Examples - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains usage examples and demonstrations.'.startswith\nE        +      where 'Examples - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains usage examples and demonstrations.' = <built-in method strip of str object at 0x000001AA12A6DF70>()\nE        +        where <built-in method strip of str object at 0x000001AA12A6DF70> = '\\nExamples - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains usage examples and demonstrations.\\n'.strip\n\ntests\\unit\\test_examples_init.py:48: AssertionError\n___________________ TestExamplesInit.test_docstring_quality ___________________\n\nself = <unit.test_examples_init.TestExamplesInit object at 0x000001AA127AD490>\n\n    def test_docstring_quality(self):\n        \"\"\"Test that the docstring meets quality standards.\"\"\"\n        import examples\n    \n        docstring = examples.__doc__\n    \n        # Should be descriptive\n        assert len(docstring.strip()) > 50\n    \n        # Should be well-formatted\n>       assert docstring.strip().startswith('\"\"\"')\nE       assert False\nE        +  where False = <built-in method startswith of str object at 0x000001AA12BCDA50>('\"\"\"')\nE        +    where <built-in method startswith of str object at 0x000001AA12BCDA50> = 'Examples - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains usage examples and demonstrations.'.startswith\nE        +      where 'Examples - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains usage examples and demonstrations.' = <built-in method strip of str object at 0x000001AA12A6D930>()\nE        +        where <built-in method strip of str object at 0x000001AA12A6D930> = '\\nExamples - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains usage examples and demonstrations.\\n'.strip\n\ntests\\unit\\test_examples_init.py:203: AssertionError\n_______________ TestLogger.test_setup_logger_default_parameters _______________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128520D0>\nmock_logger = <MagicMock id='1829970104000'>\n\n    def test_setup_logger_default_parameters(self, mock_logger):\n        \"\"\"Test setup_logger with default parameters.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n            setup_logger()\n>           mock_logger.remove.assert_called()\n\ntests\\unit\\test_logger.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <MagicMock name='mock.remove' id='1829970104672'>\n\n    def assert_called(self):\n        \"\"\"assert that the mock was called at least once\n        \"\"\"\n        if self.call_count == 0:\n            msg = (\"Expected '%s' to have been called.\" %\n                   (self._mock_name or 'mock'))\n>           raise AssertionError(msg)\nE           AssertionError: Expected 'remove' to have been called.\n\nC:\\Python313\\Lib\\unittest\\mock.py:948: AssertionError\n__________________ TestLogger.test_setup_logger_custom_level __________________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA12852210>\nmock_logger = <MagicMock id='1829968457280'>\n\n    def test_setup_logger_custom_level(self, mock_logger):\n        \"\"\"Test setup_logger with custom logging level.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n>           setup_logger(level=\"DEBUG\")\nE           TypeError: setup_logger() got an unexpected keyword argument 'level'\n\ntests\\unit\\test_logger.py:33: TypeError\n___________________ TestLogger.test_setup_logger_with_file ____________________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128063F0>\nmock_logger = <MagicMock id='1829970767424'>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_setup_logger_with_file0')\n\n    def test_setup_logger_with_file(self, mock_logger, temp_dir):\n        \"\"\"Test setup_logger with file output.\"\"\"\n        log_file = temp_dir / \"test.log\"\n        with patch('shared.utils.logger.logger', mock_logger):\n>           setup_logger(file=str(log_file))\nE           TypeError: setup_logger() got an unexpected keyword argument 'file'\n\ntests\\unit\\test_logger.py:41: TypeError\n_________________ TestLogger.test_setup_logger_custom_format __________________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA12806650>\nmock_logger = <MagicMock id='1829970114752'>\n\n    def test_setup_logger_custom_format(self, mock_logger):\n        \"\"\"Test setup_logger with custom format.\"\"\"\n        custom_format = \"{time} | {level} | {message}\"\n        with patch('shared.utils.logger.logger', mock_logger):\n>           setup_logger(format=custom_format)\nE           TypeError: setup_logger() got an unexpected keyword argument 'format'\n\ntests\\unit\\test_logger.py:49: TypeError\n_____________ TestLogger.test_setup_logger_creates_log_directory ______________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128A05F0>\nmock_logger = <MagicMock id='1829970108704'>\ntemp_dir = WindowsPath('C:/Users/MOHAMMAD ASIF/AppData/Local/Temp/pytest-of-MOHAMMAD ASIF/pytest-25/test_setup_logger_creates_log_0')\n\n    def test_setup_logger_creates_log_directory(self, mock_logger, temp_dir):\n        \"\"\"Test that setup_logger creates log directory if it doesn't exist.\"\"\"\n        log_dir = temp_dir / \"logs\"\n        log_file = log_dir / \"app.log\"\n    \n        with patch('shared.utils.logger.logger', mock_logger):\n>           setup_logger(file=str(log_file))\nE           TypeError: setup_logger() got an unexpected keyword argument 'file'\n\ntests\\unit\\test_logger.py:59: TypeError\n_____________ TestLogger.test_get_logger_returns_logger_instance ______________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128D8270>\nmock_logger = <MagicMock id='1829970102656'>\n\n    def test_get_logger_returns_logger_instance(self, mock_logger):\n        \"\"\"Test that get_logger returns a logger instance.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n>           result = get_logger()\n                     ^^^^^^^^^^^^\nE           TypeError: get_logger() missing 1 required positional argument: 'name'\n\ntests\\unit\\test_logger.py:66: TypeError\n_________________ TestLogger.test_get_logger_with_module_name _________________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128D8380>\nmock_logger = <MagicMock id='1829968458288'>\n\n    def test_get_logger_with_module_name(self, mock_logger):\n        \"\"\"Test get_logger with specific module name.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n            result = get_logger(\"test_module\")\n>           assert result == mock_logger\nE           AssertionError: assert <MagicMock na...829968459632'> == <MagicMock id='1829968458288'>\nE             \nE             Use -v to get more diff\n\ntests\\unit\\test_logger.py:73: AssertionError\n__________________ TestLogger.test_setup_logger_integration ___________________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128D2350>\nmock_logger = <MagicMock id='1829972915408'>\n\n    def test_setup_logger_integration(self, mock_logger):\n        \"\"\"Test setup_logger integration with logging system.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n            setup_logger()\n>           logger = get_logger()\n                     ^^^^^^^^^^^^\nE           TypeError: get_logger() missing 1 required positional argument: 'name'\n\ntests\\unit\\test_logger.py:143: TypeError\n_______________ TestLogger.test_logger_removes_default_handler ________________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128D25F0>\nmock_logger = <MagicMock id='1829972911040'>\n\n    def test_logger_removes_default_handler(self, mock_logger):\n        \"\"\"Test that logger removes default handler.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n            setup_logger()\n>           mock_logger.remove.assert_called()\n\ntests\\unit\\test_logger.py:150: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <MagicMock name='mock.remove' id='1829972917760'>\n\n    def assert_called(self):\n        \"\"\"assert that the mock was called at least once\n        \"\"\"\n        if self.call_count == 0:\n            msg = (\"Expected '%s' to have been called.\" %\n                   (self._mock_name or 'mock'))\n>           raise AssertionError(msg)\nE           AssertionError: Expected 'remove' to have been called.\n\nC:\\Python313\\Lib\\unittest\\mock.py:948: AssertionError\n________ TestLogger.test_setup_logger_clears_standard_logging_handlers ________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128CCA10>\nmock_logger = <MagicMock id='1829974984080'>\n\n    def test_setup_logger_clears_standard_logging_handlers(self, mock_logger):\n        \"\"\"Test that setup_logger clears standard logging handlers.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n            with patch('logging.getLogger') as mock_get_logger:\n                mock_std_logger = MagicMock()\n                mock_get_logger.return_value = mock_std_logger\n                setup_logger()\n>               mock_std_logger.handlers.clear.assert_called()\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE               AttributeError: 'builtin_function_or_method' object has no attribute 'assert_called'\n\ntests\\unit\\test_logger.py:159: AttributeError\n______________ TestLogger.test_setup_logger_valid_levels[DEBUG] _______________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA127AED50>\nlevel = 'DEBUG', mock_logger = <MagicMock id='1829974994160'>\n\n    @pytest.mark.parametrize(\"level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n    def test_setup_logger_valid_levels(self, level, mock_logger):\n        \"\"\"Test setup_logger with valid logging levels.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n>           setup_logger(level=level)\nE           TypeError: setup_logger() got an unexpected keyword argument 'level'\n\ntests\\unit\\test_logger.py:174: TypeError\n_______________ TestLogger.test_setup_logger_valid_levels[INFO] _______________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128FC050>\nlevel = 'INFO', mock_logger = <MagicMock id='1829972910704'>\n\n    @pytest.mark.parametrize(\"level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n    def test_setup_logger_valid_levels(self, level, mock_logger):\n        \"\"\"Test setup_logger with valid logging levels.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n>           setup_logger(level=level)\nE           TypeError: setup_logger() got an unexpected keyword argument 'level'\n\ntests\\unit\\test_logger.py:174: TypeError\n_____________ TestLogger.test_setup_logger_valid_levels[WARNING] ______________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128FC100>\nlevel = 'WARNING', mock_logger = <MagicMock id='1829972914400'>\n\n    @pytest.mark.parametrize(\"level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n    def test_setup_logger_valid_levels(self, level, mock_logger):\n        \"\"\"Test setup_logger with valid logging levels.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n>           setup_logger(level=level)\nE           TypeError: setup_logger() got an unexpected keyword argument 'level'\n\ntests\\unit\\test_logger.py:174: TypeError\n______________ TestLogger.test_setup_logger_valid_levels[ERROR] _______________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128B1D10>\nlevel = 'ERROR', mock_logger = <MagicMock id='1829972909360'>\n\n    @pytest.mark.parametrize(\"level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n    def test_setup_logger_valid_levels(self, level, mock_logger):\n        \"\"\"Test setup_logger with valid logging levels.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n>           setup_logger(level=level)\nE           TypeError: setup_logger() got an unexpected keyword argument 'level'\n\ntests\\unit\\test_logger.py:174: TypeError\n_____________ TestLogger.test_setup_logger_valid_levels[CRITICAL] _____________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128B2CB0>\nlevel = 'CRITICAL', mock_logger = <MagicMock id='1829972902640'>\n\n    @pytest.mark.parametrize(\"level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n    def test_setup_logger_valid_levels(self, level, mock_logger):\n        \"\"\"Test setup_logger with valid logging levels.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n>           setup_logger(level=level)\nE           TypeError: setup_logger() got an unexpected keyword argument 'level'\n\ntests\\unit\\test_logger.py:174: TypeError\n_________________ TestLogger.test_setup_logger_invalid_level __________________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA1286AE70>\nmock_logger = <MagicMock id='1829968457616'>\n\n    def test_setup_logger_invalid_level(self, mock_logger):\n        \"\"\"Test setup_logger with invalid logging level.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n>           setup_logger(level=\"INVALID_LEVEL\")\nE           TypeError: setup_logger() got an unexpected keyword argument 'level'\n\ntests\\unit\\test_logger.py:181: TypeError\n____________________ TestLogger.test_get_logger_edge_cases ____________________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128EADD0>\nmock_logger = <MagicMock id='1829970112736'>\n\n    def test_get_logger_edge_cases(self, mock_logger):\n        \"\"\"Test get_logger with edge cases.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n            # Test with None\n            result = get_logger(None)\n>           assert result == mock_logger\nE           AssertionError: assert <MagicMock na...829970103664'> == <MagicMock id='1829970112736'>\nE             \nE             Use -v to get more diff\n\ntests\\unit\\test_logger.py:190: AssertionError\n________________ TestLogger.test_intercept_handler_edge_cases _________________\n\nself = <unit.test_logger.TestLogger object at 0x000001AA128EB150>\nmock_logger = <MagicMock id='1829970105008'>\n\n    def test_intercept_handler_edge_cases(self, mock_logger):\n        \"\"\"Test InterceptHandler with edge cases.\"\"\"\n        with patch('shared.utils.logger.logger', mock_logger):\n            handler = InterceptHandler()\n    \n            # Test with None record\n>           handler.emit(None)\n\ntests\\unit\\test_logger.py:202: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <InterceptHandler (NOTSET)>, record = None\n\n    def emit(self, record):\n        # Get corresponding Loguru level if it exists\n        try:\n>           level = logger.level(record.levelname).name\n                                 ^^^^^^^^^^^^^^^^\nE           AttributeError: 'NoneType' object has no attribute 'levelname'\n\nshared\\utils\\logger.py:80: AttributeError\n______________________ TestRootInit.test_package_version ______________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA12852350>\n\n    def test_package_version(self):\n        \"\"\"Test that the package version is correctly defined.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:31: ModuleNotFoundError\n______________________ TestRootInit.test_package_author _______________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA12852490>\n\n    def test_package_author(self):\n        \"\"\"Test that the package author is correctly defined.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:38: ModuleNotFoundError\n____________________ TestRootInit.test_package_description ____________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA12806C40>\n\n    def test_package_description(self):\n        \"\"\"Test that the package description is correctly defined.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:45: ModuleNotFoundError\n_____________________ TestRootInit.test_package_docstring _____________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA12806D70>\n\n    def test_package_docstring(self):\n        \"\"\"Test that the package has appropriate documentation.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:52: ModuleNotFoundError\n____________________ TestRootInit.test_all_list_definition ____________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128F9B50>\n\n    def test_all_list_definition(self):\n        \"\"\"Test that __all__ list is properly defined.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:62: ModuleNotFoundError\n___________________ TestRootInit.test_commit_tracker_import ___________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128D87C0>\n\n    def test_commit_tracker_import(self):\n        \"\"\"Test that CommitTracker is properly imported and exported.\"\"\"\n        with patch('services.commit_tracker_service.src.commit_tracker.CommitTracker') as mock_commit_tracker:\n>           import craftnudge_ai_agent\nE           ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:72: ModuleNotFoundError\n______________________ TestRootInit.test_logger_imports _______________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128D88D0>\n\n    def test_logger_imports(self):\n        \"\"\"Test that logger functions are properly imported and exported.\"\"\"\n        with patch('shared.utils.logger.get_logger') as mock_get_logger:\n            with patch('shared.utils.logger.setup_logger') as mock_setup_logger:\n>               import craftnudge_ai_agent\nE               ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:81: ModuleNotFoundError\n_______________________ TestRootInit.test_config_import _______________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128F0850>\n\n    def test_config_import(self):\n        \"\"\"Test that config function is properly imported and exported.\"\"\"\n        with patch('shared.config.config_manager.get_config') as mock_get_config:\n>           import craftnudge_ai_agent\nE           ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:91: ModuleNotFoundError\n___________________ TestRootInit.test_all_imports_available ___________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128D3AF0>\n\n    def test_all_imports_available(self):\n        \"\"\"Test that all items in __all__ are actually available.\"\"\"\n        with patch('services.commit_tracker_service.src.commit_tracker.CommitTracker'):\n            with patch('shared.utils.logger.get_logger'):\n                with patch('shared.utils.logger.setup_logger'):\n                    with patch('shared.config.config_manager.get_config'):\n>                       import craftnudge_ai_agent\nE                       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:121: ModuleNotFoundError\n__________________ TestRootInit.test_import_statement_order ___________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128D35B0>\n\n    def test_import_statement_order(self):\n        \"\"\"Test that imports are in the correct order.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:128: ModuleNotFoundError\n_______________ TestRootInit.test_package_metadata_consistency ________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128CCE20>\n\n    def test_package_metadata_consistency(self):\n        \"\"\"Test that package metadata is consistent across different access methods.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:141: ModuleNotFoundError\n________________ TestRootInit.test_module_attributes_existence ________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA127AEED0>\n\n    def test_module_attributes_existence(self):\n        \"\"\"Test that all expected module attributes exist.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:154: ModuleNotFoundError\n____________________ TestRootInit.test_import_performance _____________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA127AF110>\n\n    def test_import_performance(self):\n        \"\"\"Test that the package can be imported without performance issues.\"\"\"\n        import time\n    \n        start_time = time.time()\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:176: ModuleNotFoundError\n_________________ TestRootInit.test_multiple_imports_behavior _________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128FC5D0>\n\n    def test_multiple_imports_behavior(self):\n        \"\"\"Test that multiple imports don't cause issues.\"\"\"\n        with patch('services.commit_tracker_service.src.commit_tracker.CommitTracker'):\n            with patch('shared.utils.logger.get_logger'):\n                with patch('shared.utils.logger.setup_logger'):\n                    with patch('shared.config.config_manager.get_config'):\n                        # Import multiple times\n>                       import craftnudge_ai_agent\nE                       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:189: ModuleNotFoundError\n____________________ TestRootInit.test_export_consistency _____________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128FC680>\n\n    def test_export_consistency(self):\n        \"\"\"Test that exports are consistent between __all__ and actual availability.\"\"\"\n        with patch('services.commit_tracker_service.src.commit_tracker.CommitTracker'):\n            with patch('shared.utils.logger.get_logger'):\n                with patch('shared.utils.logger.setup_logger'):\n                    with patch('shared.config.config_manager.get_config'):\n>                       import craftnudge_ai_agent\nE                       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:202: ModuleNotFoundError\n___________________ TestRootInit.test_docstring_formatting ____________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128B1F90>\n\n    def test_docstring_formatting(self):\n        \"\"\"Test that the docstring is properly formatted.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:217: ModuleNotFoundError\n______________________ TestRootInit.test_version_format _______________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128B2DF0>\n\n    def test_version_format(self):\n        \"\"\"Test that the version follows semantic versioning format.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:233: ModuleNotFoundError\n_______________________ TestRootInit.test_author_format _______________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA1286AD50>\n\n    def test_author_format(self):\n        \"\"\"Test that the author information is properly formatted.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:244: ModuleNotFoundError\n____________________ TestRootInit.test_description_format _____________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA129070D0>\n\n    def test_description_format(self):\n        \"\"\"Test that the description is properly formatted.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:255: ModuleNotFoundError\n___________________ TestRootInit.test_import_paths_accuracy ___________________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA12907350>\n\n    def test_import_paths_accuracy(self):\n        \"\"\"Test that import paths are accurate and follow project structure.\"\"\"\n>       import craftnudge_ai_agent\nE       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:266: ModuleNotFoundError\n____________ TestRootInit.test_package_initialization_completeness ____________\n\nself = <unit.test_root_init.TestRootInit object at 0x000001AA128BE0B0>\n\n    def test_package_initialization_completeness(self):\n        \"\"\"Test that package initialization is complete and comprehensive.\"\"\"\n        with patch('services.commit_tracker_service.src.commit_tracker.CommitTracker'):\n            with patch('shared.utils.logger.get_logger'):\n                with patch('shared.utils.logger.setup_logger'):\n                    with patch('shared.config.config_manager.get_config'):\n>                       import craftnudge_ai_agent\nE                       ModuleNotFoundError: No module named 'craftnudge_ai_agent'\n\ntests\\unit\\test_root_init.py:285: ModuleNotFoundError\n_______________ TestRootTrackCommit.test_sys_path_modification ________________\n\nself = <unittest.mock._patch object at 0x000001AA1302E4C0>\n\n    def __enter__(self):\n        \"\"\"Perform the patch.\"\"\"\n        if self.is_started:\n            raise RuntimeError(\"Patch is already started\")\n    \n        new, spec, spec_set = self.new, self.spec, self.spec_set\n        autospec, kwargs = self.autospec, self.kwargs\n        new_callable = self.new_callable\n        self.target = self.getter()\n    \n        # normalise False to None\n        if spec is False:\n            spec = None\n        if spec_set is False:\n            spec_set = None\n        if autospec is False:\n            autospec = None\n    \n        if spec is not None and autospec is not None:\n            raise TypeError(\"Can't specify spec and autospec\")\n        if ((spec is not None or autospec is not None) and\n            spec_set not in (True, None)):\n            raise TypeError(\"Can't provide explicit spec_set *and* spec or autospec\")\n    \n        original, local = self.get_original()\n    \n        if new is DEFAULT and autospec is None:\n            inherit = False\n            if spec is True:\n                # set spec to the object we are replacing\n                spec = original\n                if spec_set is True:\n                    spec_set = original\n                    spec = None\n            elif spec is not None:\n                if spec_set is True:\n                    spec_set = spec\n                    spec = None\n            elif spec_set is True:\n                spec_set = original\n    \n            if spec is not None or spec_set is not None:\n                if original is DEFAULT:\n                    raise TypeError(\"Can't use 'spec' with create=True\")\n                if isinstance(original, type):\n                    # If we're patching out a class and there is a spec\n                    inherit = True\n    \n            # Determine the Klass to use\n            if new_callable is not None:\n                Klass = new_callable\n            elif spec is None and _is_async_obj(original):\n                Klass = AsyncMock\n            elif spec is not None or spec_set is not None:\n                this_spec = spec\n                if spec_set is not None:\n                    this_spec = spec_set\n                if _is_list(this_spec):\n                    not_callable = '__call__' not in this_spec\n                else:\n                    not_callable = not callable(this_spec)\n                if _is_async_obj(this_spec):\n                    Klass = AsyncMock\n                elif not_callable:\n                    Klass = NonCallableMagicMock\n                else:\n                    Klass = MagicMock\n            else:\n                Klass = MagicMock\n    \n            _kwargs = {}\n            if spec is not None:\n                _kwargs['spec'] = spec\n            if spec_set is not None:\n                _kwargs['spec_set'] = spec_set\n    \n            # add a name to mocks\n            if (isinstance(Klass, type) and\n                issubclass(Klass, NonCallableMock) and self.attribute):\n                _kwargs['name'] = self.attribute\n    \n            _kwargs.update(kwargs)\n            new = Klass(**_kwargs)\n    \n            if inherit and _is_instance_mock(new):\n                # we can only tell if the instance should be callable if the\n                # spec is not a list\n                this_spec = spec\n                if spec_set is not None:\n                    this_spec = spec_set\n                if (not _is_list(this_spec) and not\n                    _instance_callable(this_spec)):\n                    Klass = NonCallableMagicMock\n    \n                _kwargs.pop('name')\n                new.return_value = Klass(_new_parent=new, _new_name='()',\n                                         **_kwargs)\n        elif autospec is not None:\n            # spec is ignored, new *must* be default, spec_set is treated\n            # as a boolean. Should we check spec is not None and that spec_set\n            # is a bool?\n            if new is not DEFAULT:\n                raise TypeError(\n                    \"autospec creates the mock for you. Can't specify \"\n                    \"autospec and new.\"\n                )\n            if original is DEFAULT:\n                raise TypeError(\"Can't use 'autospec' with create=True\")\n            spec_set = bool(spec_set)\n            if autospec is True:\n                autospec = original\n    \n            if _is_instance_mock(self.target):\n                raise InvalidSpecError(\n                    f'Cannot autospec attr {self.attribute!r} as the patch '\n                    f'target has already been mocked out. '\n                    f'[target={self.target!r}, attr={autospec!r}]')\n            if _is_instance_mock(autospec):\n                target_name = getattr(self.target, '__name__', self.target)\n                raise InvalidSpecError(\n                    f'Cannot autospec attr {self.attribute!r} from target '\n                    f'{target_name!r} as it has already been mocked out. '\n                    f'[target={self.target!r}, attr={autospec!r}]')\n    \n            new = create_autospec(autospec, spec_set=spec_set,\n                                  _name=self.attribute, **kwargs)\n        elif kwargs:\n            # can't set keyword args when we aren't creating the mock\n            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)\n            raise TypeError(\"Can't pass kwargs to a mock we aren't creating\")\n    \n        new_attr = new\n    \n        self.temp_original = original\n        self.is_local = local\n        self._exit_stack = contextlib.ExitStack()\n        self.is_started = True\n        try:\n>           setattr(self.target, self.attribute, new_attr)\nE           AttributeError: 'list' object attribute 'insert' is read-only\n\nC:\\Python313\\Lib\\unittest\\mock.py:1611: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_root_track_commit.TestRootTrackCommit object at 0x000001AA12852710>\n\n    def test_sys_path_modification(self):\n        \"\"\"Test that the project root is correctly added to sys.path.\"\"\"\n        # Mock the file path to return a known project root\n        mock_project_root = Path(\"/mock/project/root\")\n    \n        with patch('pathlib.Path') as mock_path:\n            mock_path.return_value.parent = mock_project_root\n    \n            # Import the module to trigger the sys.path modification\n>           with patch('sys.path.insert') as mock_insert:\n                 ^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_root_track_commit.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1624: in __enter__\n    if not self.__exit__(*sys.exc_info()):\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA1302E4C0>\nexc_info = (<class 'AttributeError'>, AttributeError(\"'list' object attribute 'insert' is read-only\"), <traceback object at 0x000001AA12FC85C0>)\n\n    def __exit__(self, *exc_info):\n        \"\"\"Undo the patch.\"\"\"\n        if not self.is_started:\n            return\n    \n        if self.is_local and self.temp_original is not DEFAULT:\n            setattr(self.target, self.attribute, self.temp_original)\n        else:\n>           delattr(self.target, self.attribute)\nE           AttributeError: 'list' object attribute 'insert' is read-only\n\nC:\\Python313\\Lib\\unittest\\mock.py:1635: AttributeError\n______________ TestRootTrackCommit.test_main_function_execution _______________\n\nself = <unit.test_root_track_commit.TestRootTrackCommit object at 0x000001AA12806EA0>\n\n    def test_main_function_execution(self):\n        \"\"\"Test that main function is called when script is executed directly.\"\"\"\n        with patch('cli.commands.track_commit.main') as mock_main:\n            with patch('sys.modules') as mock_modules:\n                # Mock __name__ to simulate direct execution\n                mock_modules.__getitem__.return_value.__name__ = '__main__'\n    \n                # Import the module\n                import track_commit\n    \n                # Verify main function was called\n>               mock_main.assert_called_once()\n\ntests\\unit\\test_root_track_commit.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <MagicMock name='main' id='1829968448880'>\n\n    def assert_called_once(self):\n        \"\"\"assert that the mock was called only once.\n        \"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to have been called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n>           raise AssertionError(msg)\nE           AssertionError: Expected 'main' to have been called once. Called 0 times.\n\nC:\\Python313\\Lib\\unittest\\mock.py:958: AssertionError\n______________ TestRootTrackCommit.test_sys_path_insertion_order ______________\n\nself = <unittest.mock._patch object at 0x000001AA1302F490>\n\n    def __enter__(self):\n        \"\"\"Perform the patch.\"\"\"\n        if self.is_started:\n            raise RuntimeError(\"Patch is already started\")\n    \n        new, spec, spec_set = self.new, self.spec, self.spec_set\n        autospec, kwargs = self.autospec, self.kwargs\n        new_callable = self.new_callable\n        self.target = self.getter()\n    \n        # normalise False to None\n        if spec is False:\n            spec = None\n        if spec_set is False:\n            spec_set = None\n        if autospec is False:\n            autospec = None\n    \n        if spec is not None and autospec is not None:\n            raise TypeError(\"Can't specify spec and autospec\")\n        if ((spec is not None or autospec is not None) and\n            spec_set not in (True, None)):\n            raise TypeError(\"Can't provide explicit spec_set *and* spec or autospec\")\n    \n        original, local = self.get_original()\n    \n        if new is DEFAULT and autospec is None:\n            inherit = False\n            if spec is True:\n                # set spec to the object we are replacing\n                spec = original\n                if spec_set is True:\n                    spec_set = original\n                    spec = None\n            elif spec is not None:\n                if spec_set is True:\n                    spec_set = spec\n                    spec = None\n            elif spec_set is True:\n                spec_set = original\n    \n            if spec is not None or spec_set is not None:\n                if original is DEFAULT:\n                    raise TypeError(\"Can't use 'spec' with create=True\")\n                if isinstance(original, type):\n                    # If we're patching out a class and there is a spec\n                    inherit = True\n    \n            # Determine the Klass to use\n            if new_callable is not None:\n                Klass = new_callable\n            elif spec is None and _is_async_obj(original):\n                Klass = AsyncMock\n            elif spec is not None or spec_set is not None:\n                this_spec = spec\n                if spec_set is not None:\n                    this_spec = spec_set\n                if _is_list(this_spec):\n                    not_callable = '__call__' not in this_spec\n                else:\n                    not_callable = not callable(this_spec)\n                if _is_async_obj(this_spec):\n                    Klass = AsyncMock\n                elif not_callable:\n                    Klass = NonCallableMagicMock\n                else:\n                    Klass = MagicMock\n            else:\n                Klass = MagicMock\n    \n            _kwargs = {}\n            if spec is not None:\n                _kwargs['spec'] = spec\n            if spec_set is not None:\n                _kwargs['spec_set'] = spec_set\n    \n            # add a name to mocks\n            if (isinstance(Klass, type) and\n                issubclass(Klass, NonCallableMock) and self.attribute):\n                _kwargs['name'] = self.attribute\n    \n            _kwargs.update(kwargs)\n            new = Klass(**_kwargs)\n    \n            if inherit and _is_instance_mock(new):\n                # we can only tell if the instance should be callable if the\n                # spec is not a list\n                this_spec = spec\n                if spec_set is not None:\n                    this_spec = spec_set\n                if (not _is_list(this_spec) and not\n                    _instance_callable(this_spec)):\n                    Klass = NonCallableMagicMock\n    \n                _kwargs.pop('name')\n                new.return_value = Klass(_new_parent=new, _new_name='()',\n                                         **_kwargs)\n        elif autospec is not None:\n            # spec is ignored, new *must* be default, spec_set is treated\n            # as a boolean. Should we check spec is not None and that spec_set\n            # is a bool?\n            if new is not DEFAULT:\n                raise TypeError(\n                    \"autospec creates the mock for you. Can't specify \"\n                    \"autospec and new.\"\n                )\n            if original is DEFAULT:\n                raise TypeError(\"Can't use 'autospec' with create=True\")\n            spec_set = bool(spec_set)\n            if autospec is True:\n                autospec = original\n    \n            if _is_instance_mock(self.target):\n                raise InvalidSpecError(\n                    f'Cannot autospec attr {self.attribute!r} as the patch '\n                    f'target has already been mocked out. '\n                    f'[target={self.target!r}, attr={autospec!r}]')\n            if _is_instance_mock(autospec):\n                target_name = getattr(self.target, '__name__', self.target)\n                raise InvalidSpecError(\n                    f'Cannot autospec attr {self.attribute!r} from target '\n                    f'{target_name!r} as it has already been mocked out. '\n                    f'[target={self.target!r}, attr={autospec!r}]')\n    \n            new = create_autospec(autospec, spec_set=spec_set,\n                                  _name=self.attribute, **kwargs)\n        elif kwargs:\n            # can't set keyword args when we aren't creating the mock\n            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)\n            raise TypeError(\"Can't pass kwargs to a mock we aren't creating\")\n    \n        new_attr = new\n    \n        self.temp_original = original\n        self.is_local = local\n        self._exit_stack = contextlib.ExitStack()\n        self.is_started = True\n        try:\n>           setattr(self.target, self.attribute, new_attr)\nE           AttributeError: 'list' object attribute 'insert' is read-only\n\nC:\\Python313\\Lib\\unittest\\mock.py:1611: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_root_track_commit.TestRootTrackCommit object at 0x000001AA128D8AF0>\n\n    def test_sys_path_insertion_order(self):\n        \"\"\"Test that project root is inserted at the beginning of sys.path.\"\"\"\n        with patch('pathlib.Path') as mock_path:\n            mock_project_root = Path(\"/test/project/root\")\n            mock_path.return_value.parent = mock_project_root\n    \n>           with patch('sys.path.insert') as mock_insert:\n                 ^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_root_track_commit.py:112: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1624: in __enter__\n    if not self.__exit__(*sys.exc_info()):\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA1302F490>\nexc_info = (<class 'AttributeError'>, AttributeError(\"'list' object attribute 'insert' is read-only\"), <traceback object at 0x000001AA1303C640>)\n\n    def __exit__(self, *exc_info):\n        \"\"\"Undo the patch.\"\"\"\n        if not self.is_started:\n            return\n    \n        if self.is_local and self.temp_original is not DEFAULT:\n            setattr(self.target, self.attribute, self.temp_original)\n        else:\n>           delattr(self.target, self.attribute)\nE           AttributeError: 'list' object attribute 'insert' is read-only\n\nC:\\Python313\\Lib\\unittest\\mock.py:1635: AttributeError\n______ TestRootTrackCommit.test_sys_path_modification_preserves_existing ______\n\nself = <unit.test_root_track_commit.TestRootTrackCommit object at 0x000001AA12915E10>\n\n    def test_sys_path_modification_preserves_existing(self):\n        \"\"\"Test that sys.path modification preserves existing paths.\"\"\"\n        original_path = ['/existing/path1', '/existing/path2']\n        sys.path = original_path.copy()\n    \n        with patch('pathlib.Path') as mock_path:\n            mock_project_root = Path(\"/test/project/root\")\n            mock_path.return_value.parent = mock_project_root\n    \n            # Import the module\n>           import track_commit\nE           ModuleNotFoundError: No module named 'track_commit'\n\ntests\\unit\\test_root_track_commit.py:161: ModuleNotFoundError\n_____________ TestRootTrackCommit.test_multiple_imports_behavior ______________\n\nself = <unittest.mock._patch object at 0x000001AA130309F0>\n\n    def __enter__(self):\n        \"\"\"Perform the patch.\"\"\"\n        if self.is_started:\n            raise RuntimeError(\"Patch is already started\")\n    \n        new, spec, spec_set = self.new, self.spec, self.spec_set\n        autospec, kwargs = self.autospec, self.kwargs\n        new_callable = self.new_callable\n        self.target = self.getter()\n    \n        # normalise False to None\n        if spec is False:\n            spec = None\n        if spec_set is False:\n            spec_set = None\n        if autospec is False:\n            autospec = None\n    \n        if spec is not None and autospec is not None:\n            raise TypeError(\"Can't specify spec and autospec\")\n        if ((spec is not None or autospec is not None) and\n            spec_set not in (True, None)):\n            raise TypeError(\"Can't provide explicit spec_set *and* spec or autospec\")\n    \n        original, local = self.get_original()\n    \n        if new is DEFAULT and autospec is None:\n            inherit = False\n            if spec is True:\n                # set spec to the object we are replacing\n                spec = original\n                if spec_set is True:\n                    spec_set = original\n                    spec = None\n            elif spec is not None:\n                if spec_set is True:\n                    spec_set = spec\n                    spec = None\n            elif spec_set is True:\n                spec_set = original\n    \n            if spec is not None or spec_set is not None:\n                if original is DEFAULT:\n                    raise TypeError(\"Can't use 'spec' with create=True\")\n                if isinstance(original, type):\n                    # If we're patching out a class and there is a spec\n                    inherit = True\n    \n            # Determine the Klass to use\n            if new_callable is not None:\n                Klass = new_callable\n            elif spec is None and _is_async_obj(original):\n                Klass = AsyncMock\n            elif spec is not None or spec_set is not None:\n                this_spec = spec\n                if spec_set is not None:\n                    this_spec = spec_set\n                if _is_list(this_spec):\n                    not_callable = '__call__' not in this_spec\n                else:\n                    not_callable = not callable(this_spec)\n                if _is_async_obj(this_spec):\n                    Klass = AsyncMock\n                elif not_callable:\n                    Klass = NonCallableMagicMock\n                else:\n                    Klass = MagicMock\n            else:\n                Klass = MagicMock\n    \n            _kwargs = {}\n            if spec is not None:\n                _kwargs['spec'] = spec\n            if spec_set is not None:\n                _kwargs['spec_set'] = spec_set\n    \n            # add a name to mocks\n            if (isinstance(Klass, type) and\n                issubclass(Klass, NonCallableMock) and self.attribute):\n                _kwargs['name'] = self.attribute\n    \n            _kwargs.update(kwargs)\n            new = Klass(**_kwargs)\n    \n            if inherit and _is_instance_mock(new):\n                # we can only tell if the instance should be callable if the\n                # spec is not a list\n                this_spec = spec\n                if spec_set is not None:\n                    this_spec = spec_set\n                if (not _is_list(this_spec) and not\n                    _instance_callable(this_spec)):\n                    Klass = NonCallableMagicMock\n    \n                _kwargs.pop('name')\n                new.return_value = Klass(_new_parent=new, _new_name='()',\n                                         **_kwargs)\n        elif autospec is not None:\n            # spec is ignored, new *must* be default, spec_set is treated\n            # as a boolean. Should we check spec is not None and that spec_set\n            # is a bool?\n            if new is not DEFAULT:\n                raise TypeError(\n                    \"autospec creates the mock for you. Can't specify \"\n                    \"autospec and new.\"\n                )\n            if original is DEFAULT:\n                raise TypeError(\"Can't use 'autospec' with create=True\")\n            spec_set = bool(spec_set)\n            if autospec is True:\n                autospec = original\n    \n            if _is_instance_mock(self.target):\n                raise InvalidSpecError(\n                    f'Cannot autospec attr {self.attribute!r} as the patch '\n                    f'target has already been mocked out. '\n                    f'[target={self.target!r}, attr={autospec!r}]')\n            if _is_instance_mock(autospec):\n                target_name = getattr(self.target, '__name__', self.target)\n                raise InvalidSpecError(\n                    f'Cannot autospec attr {self.attribute!r} from target '\n                    f'{target_name!r} as it has already been mocked out. '\n                    f'[target={self.target!r}, attr={autospec!r}]')\n    \n            new = create_autospec(autospec, spec_set=spec_set,\n                                  _name=self.attribute, **kwargs)\n        elif kwargs:\n            # can't set keyword args when we aren't creating the mock\n            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)\n            raise TypeError(\"Can't pass kwargs to a mock we aren't creating\")\n    \n        new_attr = new\n    \n        self.temp_original = original\n        self.is_local = local\n        self._exit_stack = contextlib.ExitStack()\n        self.is_started = True\n        try:\n>           setattr(self.target, self.attribute, new_attr)\nE           AttributeError: 'list' object attribute 'insert' is read-only\n\nC:\\Python313\\Lib\\unittest\\mock.py:1611: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_root_track_commit.TestRootTrackCommit object at 0x000001AA128CCEF0>\n\n    def test_multiple_imports_behavior(self):\n        \"\"\"Test that multiple imports don't cause issues.\"\"\"\n        with patch('pathlib.Path') as mock_path:\n            mock_project_root = Path(\"/test/project/root\")\n            mock_path.return_value.parent = mock_project_root\n    \n>           with patch('sys.path.insert') as mock_insert:\n                 ^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_root_track_commit.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1624: in __enter__\n    if not self.__exit__(*sys.exc_info()):\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA130309F0>\nexc_info = (<class 'AttributeError'>, AttributeError(\"'list' object attribute 'insert' is read-only\"), <traceback object at 0x000001AA12FC0E80>)\n\n    def __exit__(self, *exc_info):\n        \"\"\"Undo the patch.\"\"\"\n        if not self.is_started:\n            return\n    \n        if self.is_local and self.temp_original is not DEFAULT:\n            setattr(self.target, self.attribute, self.temp_original)\n        else:\n>           delattr(self.target, self.attribute)\nE           AttributeError: 'list' object attribute 'insert' is read-only\n\nC:\\Python313\\Lib\\unittest\\mock.py:1635: AttributeError\n_______________ TestRootTrackCommit.test_import_statement_order _______________\n\nself = <unit.test_root_track_commit.TestRootTrackCommit object at 0x000001AA128FCCB0>\n\n    def test_import_statement_order(self):\n        \"\"\"Test that imports are in the correct order.\"\"\"\n        with patch('pathlib.Path'):\n            import track_commit\n    \n            # Verify that sys and pathlib are imported before the main import\n            # This is a structural test to ensure proper import order\n            source_lines = track_commit.__doc__.split('\\n')\n>           assert any('import sys' in line for line in source_lines)\nE           assert False\nE            +  where False = any(<generator object TestRootTrackCommit.test_import_statement_order.<locals>.<genexpr> at 0x000001AA1303BB90>)\n\ntests\\unit\\test_root_track_commit.py:221: AssertionError\n_____ TestRootTrackCommit.test_sys_path_insertion_with_string_conversion ______\n\nself = <unittest.mock._patch object at 0x000001AA13031910>\n\n    def __enter__(self):\n        \"\"\"Perform the patch.\"\"\"\n        if self.is_started:\n            raise RuntimeError(\"Patch is already started\")\n    \n        new, spec, spec_set = self.new, self.spec, self.spec_set\n        autospec, kwargs = self.autospec, self.kwargs\n        new_callable = self.new_callable\n        self.target = self.getter()\n    \n        # normalise False to None\n        if spec is False:\n            spec = None\n        if spec_set is False:\n            spec_set = None\n        if autospec is False:\n            autospec = None\n    \n        if spec is not None and autospec is not None:\n            raise TypeError(\"Can't specify spec and autospec\")\n        if ((spec is not None or autospec is not None) and\n            spec_set not in (True, None)):\n            raise TypeError(\"Can't provide explicit spec_set *and* spec or autospec\")\n    \n        original, local = self.get_original()\n    \n        if new is DEFAULT and autospec is None:\n            inherit = False\n            if spec is True:\n                # set spec to the object we are replacing\n                spec = original\n                if spec_set is True:\n                    spec_set = original\n                    spec = None\n            elif spec is not None:\n                if spec_set is True:\n                    spec_set = spec\n                    spec = None\n            elif spec_set is True:\n                spec_set = original\n    \n            if spec is not None or spec_set is not None:\n                if original is DEFAULT:\n                    raise TypeError(\"Can't use 'spec' with create=True\")\n                if isinstance(original, type):\n                    # If we're patching out a class and there is a spec\n                    inherit = True\n    \n            # Determine the Klass to use\n            if new_callable is not None:\n                Klass = new_callable\n            elif spec is None and _is_async_obj(original):\n                Klass = AsyncMock\n            elif spec is not None or spec_set is not None:\n                this_spec = spec\n                if spec_set is not None:\n                    this_spec = spec_set\n                if _is_list(this_spec):\n                    not_callable = '__call__' not in this_spec\n                else:\n                    not_callable = not callable(this_spec)\n                if _is_async_obj(this_spec):\n                    Klass = AsyncMock\n                elif not_callable:\n                    Klass = NonCallableMagicMock\n                else:\n                    Klass = MagicMock\n            else:\n                Klass = MagicMock\n    \n            _kwargs = {}\n            if spec is not None:\n                _kwargs['spec'] = spec\n            if spec_set is not None:\n                _kwargs['spec_set'] = spec_set\n    \n            # add a name to mocks\n            if (isinstance(Klass, type) and\n                issubclass(Klass, NonCallableMock) and self.attribute):\n                _kwargs['name'] = self.attribute\n    \n            _kwargs.update(kwargs)\n            new = Klass(**_kwargs)\n    \n            if inherit and _is_instance_mock(new):\n                # we can only tell if the instance should be callable if the\n                # spec is not a list\n                this_spec = spec\n                if spec_set is not None:\n                    this_spec = spec_set\n                if (not _is_list(this_spec) and not\n                    _instance_callable(this_spec)):\n                    Klass = NonCallableMagicMock\n    \n                _kwargs.pop('name')\n                new.return_value = Klass(_new_parent=new, _new_name='()',\n                                         **_kwargs)\n        elif autospec is not None:\n            # spec is ignored, new *must* be default, spec_set is treated\n            # as a boolean. Should we check spec is not None and that spec_set\n            # is a bool?\n            if new is not DEFAULT:\n                raise TypeError(\n                    \"autospec creates the mock for you. Can't specify \"\n                    \"autospec and new.\"\n                )\n            if original is DEFAULT:\n                raise TypeError(\"Can't use 'autospec' with create=True\")\n            spec_set = bool(spec_set)\n            if autospec is True:\n                autospec = original\n    \n            if _is_instance_mock(self.target):\n                raise InvalidSpecError(\n                    f'Cannot autospec attr {self.attribute!r} as the patch '\n                    f'target has already been mocked out. '\n                    f'[target={self.target!r}, attr={autospec!r}]')\n            if _is_instance_mock(autospec):\n                target_name = getattr(self.target, '__name__', self.target)\n                raise InvalidSpecError(\n                    f'Cannot autospec attr {self.attribute!r} from target '\n                    f'{target_name!r} as it has already been mocked out. '\n                    f'[target={self.target!r}, attr={autospec!r}]')\n    \n            new = create_autospec(autospec, spec_set=spec_set,\n                                  _name=self.attribute, **kwargs)\n        elif kwargs:\n            # can't set keyword args when we aren't creating the mock\n            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)\n            raise TypeError(\"Can't pass kwargs to a mock we aren't creating\")\n    \n        new_attr = new\n    \n        self.temp_original = original\n        self.is_local = local\n        self._exit_stack = contextlib.ExitStack()\n        self.is_started = True\n        try:\n>           setattr(self.target, self.attribute, new_attr)\nE           AttributeError: 'list' object attribute 'insert' is read-only\n\nC:\\Python313\\Lib\\unittest\\mock.py:1611: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <unit.test_root_track_commit.TestRootTrackCommit object at 0x000001AA1290E2B0>\n\n    def test_sys_path_insertion_with_string_conversion(self):\n        \"\"\"Test that project root is converted to string when inserted into sys.path.\"\"\"\n        with patch('pathlib.Path') as mock_path:\n            mock_project_root = Path(\"/test/project/root\")\n            mock_path.return_value.parent = mock_project_root\n    \n>           with patch('sys.path.insert') as mock_insert:\n                 ^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_root_track_commit.py:246: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1624: in __enter__\n    if not self.__exit__(*sys.exc_info()):\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA13031910>\nexc_info = (<class 'AttributeError'>, AttributeError(\"'list' object attribute 'insert' is read-only\"), <traceback object at 0x000001AA12D1B780>)\n\n    def __exit__(self, *exc_info):\n        \"\"\"Undo the patch.\"\"\"\n        if not self.is_started:\n            return\n    \n        if self.is_local and self.temp_original is not DEFAULT:\n            setattr(self.target, self.attribute, self.temp_original)\n        else:\n>           delattr(self.target, self.attribute)\nE           AttributeError: 'list' object attribute 'insert' is read-only\n\nC:\\Python313\\Lib\\unittest\\mock.py:1635: AttributeError\n_________________ TestServicesInit.test_docstring_formatting __________________\n\nself = <unit.test_services_init.TestServicesInit object at 0x000001AA12852C10>\n\n    def test_docstring_formatting(self):\n        \"\"\"Test that the docstring is properly formatted.\"\"\"\n        import services\n    \n        docstring = services.__doc__\n    \n        # Should contain proper formatting\n>       assert docstring.strip().startswith('\"\"\"')\nE       assert False\nE        +  where False = <built-in method startswith of str object at 0x000001AA12B7DBC0>('\"\"\"')\nE        +    where <built-in method startswith of str object at 0x000001AA12B7DBC0> = 'Services - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains all microservices for the CraftNudge AI Agent.'.startswith\nE        +      where 'Services - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains all microservices for the CraftNudge AI Agent.' = <built-in method strip of str object at 0x000001AA12B7E3A0>()\nE        +        where <built-in method strip of str object at 0x000001AA12B7E3A0> = '\\nServices - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains all microservices for the CraftNudge AI Agent.\\n'.strip\n\ntests\\unit\\test_services_init.py:48: AssertionError\n___________________ TestServicesInit.test_docstring_quality ___________________\n\nself = <unit.test_services_init.TestServicesInit object at 0x000001AA127AFAD0>\n\n    def test_docstring_quality(self):\n        \"\"\"Test that the docstring meets quality standards.\"\"\"\n        import services\n    \n        docstring = services.__doc__\n    \n        # Should be descriptive\n        assert len(docstring.strip()) > 50\n    \n        # Should be well-formatted\n>       assert docstring.strip().startswith('\"\"\"')\nE       assert False\nE        +  where False = <built-in method startswith of str object at 0x000001AA12B7C960>('\"\"\"')\nE        +    where <built-in method startswith of str object at 0x000001AA12B7C960> = 'Services - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains all microservices for the CraftNudge AI Agent.'.startswith\nE        +      where 'Services - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains all microservices for the CraftNudge AI Agent.' = <built-in method strip of str object at 0x000001AA12B7CFF0>()\nE        +        where <built-in method strip of str object at 0x000001AA12B7CFF0> = '\\nServices - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains all microservices for the CraftNudge AI Agent.\\n'.strip\n\ntests\\unit\\test_services_init.py:204: AssertionError\n__________________ TestSharedConfigInit.test_package_version __________________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12852E90>\n\n    def test_package_version(self):\n        \"\"\"Test that the package version is correctly defined.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n>                           assert hasattr(config_package, '__version__')\nE                           AssertionError: assert False\nE                            +  where False = hasattr(<module 'shared.config' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\config\\\\__init__.py'>, '__version__')\n\ntests\\unit\\test_shared_config_init.py:38: AssertionError\n________________ TestSharedConfigInit.test_all_list_definition ________________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA128069E0>\n\n    def test_all_list_definition(self):\n        \"\"\"Test that __all__ list is properly defined.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n                            assert hasattr(config_package, '__all__')\n                            assert isinstance(config_package.__all__, list)\n                            expected_exports = [\n                                'get_config',\n                                'get_config_value',\n                                'reload_config',\n                                'update_config',\n                                'create_default_config'\n                            ]\n>                           assert config_package.__all__ == expected_exports\nE                           AssertionError: assert [] == ['get_config'...fault_config']\nE                             \nE                             Right contains 5 more items, first extra item: 'get_config'\nE                             Use -v to get more diff\n\ntests\\unit\\test_shared_config_init.py:74: AssertionError\n_________________ TestSharedConfigInit.test_get_config_import _________________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA128075C0>\n\n    def test_get_config_import(self):\n        \"\"\"Test that get_config is properly imported and exported.\"\"\"\n        with patch('shared.config.config_manager.get_config') as mock_get_config:\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n>                           assert hasattr(config_package, 'get_config')\nE                           AssertionError: assert False\nE                            +  where False = hasattr(<module 'shared.config' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\config\\\\__init__.py'>, 'get_config')\n\ntests\\unit\\test_shared_config_init.py:85: AssertionError\n______________ TestSharedConfigInit.test_get_config_value_import ______________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA1292E8D0>\n\n    def test_get_config_value_import(self):\n        \"\"\"Test that get_config_value is properly imported and exported.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value') as mock_get_config_value:\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n>                           assert hasattr(config_package, 'get_config_value')\nE                           AssertionError: assert False\nE                            +  where False = hasattr(<module 'shared.config' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\config\\\\__init__.py'>, 'get_config_value')\n\ntests\\unit\\test_shared_config_init.py:97: AssertionError\n_______________ TestSharedConfigInit.test_reload_config_import ________________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA128D8F30>\n\n    def test_reload_config_import(self):\n        \"\"\"Test that reload_config is properly imported and exported.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config') as mock_reload_config:\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n>                           assert hasattr(config_package, 'reload_config')\nE                           AssertionError: assert False\nE                            +  where False = hasattr(<module 'shared.config' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\config\\\\__init__.py'>, 'reload_config')\n\ntests\\unit\\test_shared_config_init.py:109: AssertionError\n_______________ TestSharedConfigInit.test_update_config_import ________________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA128D9040>\n\n    def test_update_config_import(self):\n        \"\"\"Test that update_config is properly imported and exported.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config') as mock_update_config:\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n>                           assert hasattr(config_package, 'update_config')\nE                           AssertionError: assert False\nE                            +  where False = hasattr(<module 'shared.config' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\config\\\\__init__.py'>, 'update_config')\n\ntests\\unit\\test_shared_config_init.py:121: AssertionError\n___________ TestSharedConfigInit.test_create_default_config_import ____________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA128F1D50>\n\n    def test_create_default_config_import(self):\n        \"\"\"Test that create_default_config is properly imported and exported.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config') as mock_create_default_config:\n                            import shared.config as config_package\n    \n>                           assert hasattr(config_package, 'create_default_config')\nE                           AssertionError: assert False\nE                            +  where False = hasattr(<module 'shared.config' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\config\\\\__init__.py'>, 'create_default_config')\n\ntests\\unit\\test_shared_config_init.py:133: AssertionError\n_________ TestSharedConfigInit.test_import_error_handling_get_config __________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA128F1E50>\n\n    def test_import_error_handling_get_config(self):\n        \"\"\"Test behavior when get_config import fails.\"\"\"\n        with patch('shared.config.config_manager.get_config',\n                  side_effect=ImportError(\"Module not found\")):\n>           with pytest.raises(ImportError):\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           Failed: DID NOT RAISE <class 'ImportError'>\n\ntests\\unit\\test_shared_config_init.py:140: Failed\n______ TestSharedConfigInit.test_import_error_handling_get_config_value _______\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12885130>\n\n    def test_import_error_handling_get_config_value(self):\n        \"\"\"Test behavior when get_config_value import fails.\"\"\"\n        with patch('shared.config.config_manager.get_config_value',\n                  side_effect=ImportError(\"Module not found\")):\n>           with pytest.raises(ImportError):\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           Failed: DID NOT RAISE <class 'ImportError'>\n\ntests\\unit\\test_shared_config_init.py:147: Failed\n________ TestSharedConfigInit.test_import_error_handling_reload_config ________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12885220>\n\n    def test_import_error_handling_reload_config(self):\n        \"\"\"Test behavior when reload_config import fails.\"\"\"\n        with patch('shared.config.config_manager.reload_config',\n                  side_effect=ImportError(\"Module not found\")):\n>           with pytest.raises(ImportError):\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           Failed: DID NOT RAISE <class 'ImportError'>\n\ntests\\unit\\test_shared_config_init.py:154: Failed\n________ TestSharedConfigInit.test_import_error_handling_update_config ________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA129483D0>\n\n    def test_import_error_handling_update_config(self):\n        \"\"\"Test behavior when update_config import fails.\"\"\"\n        with patch('shared.config.config_manager.update_config',\n                  side_effect=ImportError(\"Module not found\")):\n>           with pytest.raises(ImportError):\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           Failed: DID NOT RAISE <class 'ImportError'>\n\ntests\\unit\\test_shared_config_init.py:161: Failed\n____ TestSharedConfigInit.test_import_error_handling_create_default_config ____\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12948750>\n\n    def test_import_error_handling_create_default_config(self):\n        \"\"\"Test behavior when create_default_config import fails.\"\"\"\n        with patch('shared.config.config_manager.create_default_config',\n                  side_effect=ImportError(\"Module not found\")):\n>           with pytest.raises(ImportError):\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           Failed: DID NOT RAISE <class 'ImportError'>\n\ntests\\unit\\test_shared_config_init.py:168: Failed\n______________ TestSharedConfigInit.test_import_statement_order _______________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA127AF710>\n\n    def test_import_statement_order(self):\n        \"\"\"Test that imports are in the correct order.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n                            # Verify that the imports are in the expected order in the source\n                            source_lines = config_package.__doc__.split('\\n')\n>                           assert any('from .config_manager import (' in line\n                                      for line in source_lines)\nE                           assert False\nE                            +  where False = any(<generator object TestSharedConfigInit.test_import_statement_order.<locals>.<genexpr> at 0x000001AA1305CC70>)\n\ntests\\unit\\test_shared_config_init.py:194: AssertionError\n___________ TestSharedConfigInit.test_package_metadata_consistency ____________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA129541D0>\n\n    def test_package_metadata_consistency(self):\n        \"\"\"Test that package metadata is consistent across different access methods.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n                            # Test version consistency\n>                           assert config_package.__version__ == \"1.0.0\"\n                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\nE                           AttributeError: module 'shared.config' has no attribute '__version__'\n\ntests\\unit\\test_shared_config_init.py:217: AttributeError\n____________ TestSharedConfigInit.test_module_attributes_existence ____________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA128FDB20>\n\n    def test_module_attributes_existence(self):\n        \"\"\"Test that all expected module attributes exist.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n                            expected_attributes = [\n                                '__version__',\n                                '__doc__',\n                                '__all__',\n                                'get_config',\n                                'get_config_value',\n                                'reload_config',\n                                'update_config',\n                                'create_default_config'\n                            ]\n    \n                            for attr in expected_attributes:\n>                               assert hasattr(config_package, attr)\nE                               AssertionError: assert False\nE                                +  where False = hasattr(<module 'shared.config' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\config\\\\__init__.py'>, '__version__')\n\ntests\\unit\\test_shared_config_init.py:240: AssertionError\n_____________ TestSharedConfigInit.test_multiple_imports_behavior _____________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12959130>\n\n    def test_multiple_imports_behavior(self):\n        \"\"\"Test that multiple imports don't cause issues.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            # Import multiple times\n                            import shared.config\n                            import shared.config\n                            import shared.config\n    \n                            # All imports should work without issues\n>                           assert shared.config.__version__ == \"1.0.0\"\n                                   ^^^^^^^^^^^^^^^^^^^^^^^^^\nE                           AttributeError: module 'shared.config' has no attribute '__version__'\n\ntests\\unit\\test_shared_config_init.py:271: AttributeError\n________________ TestSharedConfigInit.test_export_consistency _________________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12959090>\n\n    def test_export_consistency(self):\n        \"\"\"Test that exports are consistent between __all__ and actual availability.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n                            # All items in __all__ should be available\n                            for item in config_package.__all__:\n                                assert hasattr(config_package, item)\n    \n                            # All available items should be in __all__ (for public API)\n                            public_attrs = [attr for attr in dir(config_package)\n                                           if not attr.startswith('_')]\n                            for attr in public_attrs:\n                                if attr not in ['__version__']:\n>                                   assert attr in config_package.__all__\nE                                   AssertionError: assert 'config_manager' in []\nE                                    +  where [] = <module 'shared.config' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\config\\\\__init__.py'>.__all__\n\ntests\\unit\\test_shared_config_init.py:291: AssertionError\n_______________ TestSharedConfigInit.test_docstring_formatting ________________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12932600>\n\n    def test_docstring_formatting(self):\n        \"\"\"Test that the docstring is properly formatted.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n                            docstring = config_package.__doc__\n    \n                            # Should contain proper formatting\n>                           assert docstring.strip().startswith('\"\"\"')\nE                           assert False\nE                            +  where False = <built-in method startswith of str object at 0x000001AA12B7DD10>('\"\"\"')\nE                            +    where <built-in method startswith of str object at 0x000001AA12B7DD10> = 'Shared Configuration - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared configuration management.'.startswith\nE                            +      where 'Shared Configuration - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared configuration management.' = <built-in method strip of str object at 0x000001AA12B7DE60>()\nE                            +        where <built-in method strip of str object at 0x000001AA12B7DE60> = '\\nShared Configuration - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared configuration management.\\n'.strip\n\ntests\\unit\\test_shared_config_init.py:305: AssertionError\n__________________ TestSharedConfigInit.test_version_format ___________________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12961FD0>\n\n    def test_version_format(self):\n        \"\"\"Test that the version follows semantic versioning format.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n>                           version = config_package.__version__\n                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^\nE                           AttributeError: module 'shared.config' has no attribute '__version__'\n\ntests\\unit\\test_shared_config_init.py:323: AttributeError\n_______________ TestSharedConfigInit.test_import_paths_accuracy _______________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12962350>\n\n    def test_import_paths_accuracy(self):\n        \"\"\"Test that import paths are accurate and follow project structure.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n                            # Verify that the import paths match the expected project structure\n                            source_lines = config_package.__doc__.split('\\n')\n    \n                            # Check for correct import paths\n>                           assert any('from .config_manager import (' in line\n                                      for line in source_lines)\nE                           assert False\nE                            +  where False = any(<generator object TestSharedConfigInit.test_import_paths_accuracy.<locals>.<genexpr> at 0x000001AA1301BE00>)\n\ntests\\unit\\test_shared_config_init.py:343: AssertionError\n________ TestSharedConfigInit.test_package_initialization_completeness ________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12942A50>\n\n    def test_package_initialization_completeness(self):\n        \"\"\"Test that package initialization is complete and comprehensive.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n                            # Test that all core functions are available\n>                           assert hasattr(config_package, 'get_config')\nE                           AssertionError: assert False\nE                            +  where False = hasattr(<module 'shared.config' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\config\\\\__init__.py'>, 'get_config')\n\ntests\\unit\\test_shared_config_init.py:366: AssertionError\n_______________ TestSharedConfigInit.test_function_availability _______________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA12942C80>\n\n    def test_function_availability(self):\n        \"\"\"Test that all main functions are available and properly typed.\"\"\"\n        with patch('shared.config.config_manager.get_config') as mock_get_config:\n            with patch('shared.config.config_manager.get_config_value') as mock_get_config_value:\n                with patch('shared.config.config_manager.reload_config') as mock_reload_config:\n                    with patch('shared.config.config_manager.update_config') as mock_update_config:\n                        with patch('shared.config.config_manager.create_default_config') as mock_create_default_config:\n                            import shared.config as config_package\n    \n                            # Test that functions are callable\n>                           assert callable(config_package.get_config)\n                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\nE                           AttributeError: module 'shared.config' has no attribute 'get_config'\n\ntests\\unit\\test_shared_config_init.py:394: AttributeError\n________________ TestSharedConfigInit.test_function_signatures ________________\n\nself = <unit.test_shared_config_init.TestSharedConfigInit object at 0x000001AA1293E8D0>\n\n    def test_function_signatures(self):\n        \"\"\"Test that all functions have the expected signatures.\"\"\"\n        with patch('shared.config.config_manager.get_config'):\n            with patch('shared.config.config_manager.get_config_value'):\n                with patch('shared.config.config_manager.reload_config'):\n                    with patch('shared.config.config_manager.update_config'):\n                        with patch('shared.config.config_manager.create_default_config'):\n                            import shared.config as config_package\n    \n                            # Test that all functions are callable and have signatures\n                            import inspect\n    \n>                           assert inspect.isfunction(config_package.get_config)\n                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^\nE                           AttributeError: module 'shared.config' has no attribute 'get_config'\n\ntests\\unit\\test_shared_config_init.py:419: AttributeError\n__________________ TestSharedInit.test_docstring_formatting ___________________\n\nself = <unit.test_shared_init.TestSharedInit object at 0x000001AA12853250>\n\n    def test_docstring_formatting(self):\n        \"\"\"Test that the docstring is properly formatted.\"\"\"\n        import shared\n    \n        docstring = shared.__doc__\n    \n        # Should contain proper formatting\n>       assert docstring.strip().startswith('\"\"\"')\nE       assert False\nE        +  where False = <built-in method startswith of str object at 0x000001AA12A46290>('\"\"\"')\nE        +    where <built-in method startswith of str object at 0x000001AA12A46290> = 'Shared Components - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared components used across all services.'.startswith\nE        +      where 'Shared Components - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared components used across all services.' = <built-in method strip of str object at 0x000001AA12A45E70>()\nE        +        where <built-in method strip of str object at 0x000001AA12A45E70> = '\\nShared Components - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared components used across all services.\\n'.strip\n\ntests\\unit\\test_shared_init.py:48: AssertionError\n____________________ TestSharedInit.test_docstring_quality ____________________\n\nself = <unit.test_shared_init.TestSharedInit object at 0x000001AA12954350>\n\n    def test_docstring_quality(self):\n        \"\"\"Test that the docstring meets quality standards.\"\"\"\n        import shared\n    \n        docstring = shared.__doc__\n    \n        # Should be descriptive\n        assert len(docstring.strip()) > 50\n    \n        # Should be well-formatted\n>       assert docstring.strip().startswith('\"\"\"')\nE       assert False\nE        +  where False = <built-in method startswith of str object at 0x000001AA12A45E70>('\"\"\"')\nE        +    where <built-in method startswith of str object at 0x000001AA12A45E70> = 'Shared Components - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared components used across all services.'.startswith\nE        +      where 'Shared Components - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared components used across all services.' = <built-in method strip of str object at 0x000001AA12A46290>()\nE        +        where <built-in method strip of str object at 0x000001AA12A46290> = '\\nShared Components - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared components used across all services.\\n'.strip\n\ntests\\unit\\test_shared_init.py:202: AssertionError\n___________ TestSharedInit.test_package_initialization_cleanliness ____________\n\nself = <unit.test_shared_init.TestSharedInit object at 0x000001AA128FE4C0>\n\n    def test_package_initialization_cleanliness(self):\n        \"\"\"Test that package initialization is clean and doesn't pollute namespace.\"\"\"\n        import shared\n    \n        # Should only have expected attributes\n        expected_attrs = {'__file__', '__name__', '__doc__', '__package__', '__path__'}\n        actual_attrs = set(dir(shared))\n    \n        # Should not have unexpected public attributes\n        unexpected_public = [attr for attr in actual_attrs\n                           if not attr.startswith('_') and attr not in expected_attrs]\n>       assert len(unexpected_public) == 0\nE       AssertionError: assert 5 == 0\nE        +  where 5 = len(['error_handler', 'config', 'config_manager', 'logger', 'utils'])\n\ntests\\unit\\test_shared_init.py:237: AssertionError\n__________________ TestSharedUtilsInit.test_package_version ___________________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA12984690>\n\n    def test_package_version(self):\n        \"\"\"Test that the package version is correctly defined.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n>                                                       assert hasattr(utils_package, '__version__')\nE                                                       AssertionError: assert False\nE                                                        +  where False = hasattr(<module 'shared.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\utils\\\\__init__.py'>, '__version__')\n\ntests\\unit\\test_shared_utils_init.py:45: AssertionError\n________________ TestSharedUtilsInit.test_all_list_definition _________________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA12807A80>\n\n    def test_all_list_definition(self):\n        \"\"\"Test that __all__ list is properly defined.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n                                                        assert hasattr(utils_package, '__all__')\n                                                        assert isinstance(utils_package.__all__, list)\n                                                        expected_exports = [\n                                                            'get_logger',\n                                                            'setup_logger',\n                                                            'CraftNudgeError',\n                                                            'GitRepositoryError',\n                                                            'DataStoreError',\n                                                            'ValidationError',\n                                                            'ConfigurationError',\n                                                            'handle_error',\n                                                            'validate_required_fields',\n                                                            'validate_field_type',\n                                                            'safe_execute',\n                                                            'retry_on_error'\n                                                        ]\n>                                                       assert utils_package.__all__ == expected_exports\nE                                                       AssertionError: assert [] == ['get_logger'...onError', ...]\nE                                                         \nE                                                         Right contains 12 more items, first extra item: 'get_logger'\nE                                                         Use -v to get more diff\n\ntests\\unit\\test_shared_utils_init.py:102: AssertionError\n___________________ TestSharedUtilsInit.test_logger_imports ___________________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA12807BB0>\n\n    def test_logger_imports(self):\n        \"\"\"Test that logger functions are properly imported and exported.\"\"\"\n        with patch('shared.utils.logger.get_logger') as mock_get_logger:\n            with patch('shared.utils.logger.setup_logger') as mock_setup_logger:\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n>                                                       assert hasattr(utils_package, 'get_logger')\nE                                                       AssertionError: assert False\nE                                                        +  where False = hasattr(<module 'shared.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\utils\\\\__init__.py'>, 'get_logger')\n\ntests\\unit\\test_shared_utils_init.py:120: AssertionError\n_______________ TestSharedUtilsInit.test_error_classes_imports ________________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA129684D0>\n\n    def test_error_classes_imports(self):\n        \"\"\"Test that error classes are properly imported and exported.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError') as mock_craft_nudge_error:\n                    with patch('shared.utils.error_handler.GitRepositoryError') as mock_git_repo_error:\n                        with patch('shared.utils.error_handler.DataStoreError') as mock_data_store_error:\n                            with patch('shared.utils.error_handler.ValidationError') as mock_validation_error:\n                                with patch('shared.utils.error_handler.ConfigurationError') as mock_config_error:\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n>                                                       assert hasattr(utils_package, 'CraftNudgeError')\nE                                                       AssertionError: assert False\nE                                                        +  where False = hasattr(<module 'shared.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\utils\\\\__init__.py'>, 'CraftNudgeError')\n\ntests\\unit\\test_shared_utils_init.py:141: AssertionError\n__________ TestSharedUtilsInit.test_error_handler_functions_imports ___________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA128D9D00>\n\n    def test_error_handler_functions_imports(self):\n        \"\"\"Test that error handler functions are properly imported and exported.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error') as mock_handle_error:\n                                        with patch('shared.utils.error_handler.validate_required_fields') as mock_validate_required:\n                                            with patch('shared.utils.error_handler.validate_field_type') as mock_validate_type:\n                                                with patch('shared.utils.error_handler.safe_execute') as mock_safe_execute:\n                                                    with patch('shared.utils.error_handler.retry_on_error') as mock_retry_on_error:\n                                                        import shared.utils as utils_package\n    \n>                                                       assert hasattr(utils_package, 'handle_error')\nE                                                       AssertionError: assert False\nE                                                        +  where False = hasattr(<module 'shared.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\utils\\\\__init__.py'>, 'handle_error')\n\ntests\\unit\\test_shared_utils_init.py:169: AssertionError\n____________ TestSharedUtilsInit.test_import_error_handling_logger ____________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA128D9E10>\n\n    def test_import_error_handling_logger(self):\n        \"\"\"Test behavior when logger import fails.\"\"\"\n        with patch('shared.utils.logger.get_logger',\n                  side_effect=ImportError(\"Module not found\")):\n>           with pytest.raises(ImportError):\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           Failed: DID NOT RAISE <class 'ImportError'>\n\ntests\\unit\\test_shared_utils_init.py:185: Failed\n________ TestSharedUtilsInit.test_import_error_handling_error_handler _________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA128F3D50>\n\n    def test_import_error_handling_error_handler(self):\n        \"\"\"Test behavior when error_handler import fails.\"\"\"\n        with patch('shared.utils.error_handler.CraftNudgeError',\n                  side_effect=ImportError(\"Module not found\")):\n>           with pytest.raises(ImportError):\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           Failed: DID NOT RAISE <class 'ImportError'>\n\ntests\\unit\\test_shared_utils_init.py:192: Failed\n_______________ TestSharedUtilsInit.test_import_statement_order _______________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA128857C0>\n\n    def test_import_statement_order(self):\n        \"\"\"Test that imports are in the correct order.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n                                                        # Verify that the imports are in the expected order in the source\n                                                        source_lines = utils_package.__doc__.split('\\n')\n>                                                       assert any('from .logger import get_logger, setup_logger' in line\n                                                                  for line in source_lines)\nE                                                       assert False\nE                                                        +  where False = any(<generator object TestSharedUtilsInit.test_import_statement_order.<locals>.<genexpr> at 0x000001AA12F8B850>)\n\ntests\\unit\\test_shared_utils_init.py:232: AssertionError\n____________ TestSharedUtilsInit.test_package_metadata_consistency ____________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA128858B0>\n\n    def test_package_metadata_consistency(self):\n        \"\"\"Test that package metadata is consistent across different access methods.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n                                                        # Test version consistency\n>                                                       assert utils_package.__version__ == \"1.0.0\"\n                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^\nE                                                       AttributeError: module 'shared.utils' has no attribute '__version__'\n\ntests\\unit\\test_shared_utils_init.py:274: AttributeError\n____________ TestSharedUtilsInit.test_module_attributes_existence _____________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA12994750>\n\n    def test_module_attributes_existence(self):\n        \"\"\"Test that all expected module attributes exist.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n                                                        expected_attributes = [\n                                                            '__version__',\n                                                            '__doc__',\n                                                            '__all__',\n                                                            'get_logger',\n                                                            'setup_logger',\n                                                            'CraftNudgeError',\n                                                            'GitRepositoryError',\n                                                            'DataStoreError',\n                                                            'ValidationError',\n                                                            'ConfigurationError',\n                                                            'handle_error',\n                                                            'validate_required_fields',\n                                                            'validate_field_type',\n                                                            'safe_execute',\n                                                            'retry_on_error'\n                                                        ]\n    \n                                                        for attr in expected_attributes:\n>                                                           assert hasattr(utils_package, attr)\nE                                                           AssertionError: assert False\nE                                                            +  where False = hasattr(<module 'shared.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\utils\\\\__init__.py'>, '__version__')\n\ntests\\unit\\test_shared_utils_init.py:311: AssertionError\n_____________ TestSharedUtilsInit.test_multiple_imports_behavior ______________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA128CDB20>\n\n    def test_multiple_imports_behavior(self):\n        \"\"\"Test that multiple imports don't cause issues.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        # Import multiple times\n                                                        import shared.utils\n                                                        import shared.utils\n                                                        import shared.utils\n    \n                                                        # All imports should work without issues\n>                                                       assert shared.utils.__version__ == \"1.0.0\"\n                                                               ^^^^^^^^^^^^^^^^^^^^^^^^\nE                                                       AttributeError: module 'shared.utils' has no attribute '__version__'\n\ntests\\unit\\test_shared_utils_init.py:356: AttributeError\n_________________ TestSharedUtilsInit.test_export_consistency _________________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA12954650>\n\n    def test_export_consistency(self):\n        \"\"\"Test that exports are consistent between __all__ and actual availability.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n                                                        # All items in __all__ should be available\n                                                        for item in utils_package.__all__:\n                                                            assert hasattr(utils_package, item)\n    \n                                                        # All available items should be in __all__ (for public API)\n                                                        public_attrs = [attr for attr in dir(utils_package)\n                                                                       if not attr.startswith('_')]\n                                                        for attr in public_attrs:\n                                                            if attr not in ['__version__']:\n>                                                               assert attr in utils_package.__all__\nE                                                               AssertionError: assert 'error_handler' in []\nE                                                                +  where [] = <module 'shared.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\utils\\\\__init__.py'>.__all__\n\ntests\\unit\\test_shared_utils_init.py:383: AssertionError\n________________ TestSharedUtilsInit.test_docstring_formatting ________________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA12954890>\n\n    def test_docstring_formatting(self):\n        \"\"\"Test that the docstring is properly formatted.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n                                                        docstring = utils_package.__doc__\n    \n                                                        # Should contain proper formatting\n>                                                       assert docstring.strip().startswith('\"\"\"')\nE                                                       assert False\nE                                                        +  where False = <built-in method startswith of str object at 0x000001AA129E8EA0>('\"\"\"')\nE                                                        +    where <built-in method startswith of str object at 0x000001AA129E8EA0> = 'Shared Utilities - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared utility functions and classes.'.startswith\nE                                                        +      where 'Shared Utilities - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared utility functions and classes.' = <built-in method strip of str object at 0x000001AA12B7DFB0>()\nE                                                        +        where <built-in method strip of str object at 0x000001AA12B7DFB0> = '\\nShared Utilities - User Story 2.1.1: Behavior Tracker \u2013 Git Commit Logger\\n\\nThis package contains shared utility functions and classes.\\n'.strip\n\ntests\\unit\\test_shared_utils_init.py:404: AssertionError\n___________________ TestSharedUtilsInit.test_version_format ___________________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA128FEC50>\n\n    def test_version_format(self):\n        \"\"\"Test that the version follows semantic versioning format.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n>                                                       version = utils_package.__version__\n                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^\nE                                                       AttributeError: module 'shared.utils' has no attribute '__version__'\n\ntests\\unit\\test_shared_utils_init.py:429: AttributeError\n_______________ TestSharedUtilsInit.test_import_paths_accuracy ________________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA128FED00>\n\n    def test_import_paths_accuracy(self):\n        \"\"\"Test that import paths are accurate and follow project structure.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n                                                        # Verify that the import paths match the expected project structure\n                                                        source_lines = utils_package.__doc__.split('\\n')\n    \n                                                        # Check for correct import paths\n>                                                       assert any('from .logger import get_logger, setup_logger' in line\n                                                                  for line in source_lines)\nE                                                       assert False\nE                                                        +  where False = any(<generator object TestSharedUtilsInit.test_import_paths_accuracy.<locals>.<genexpr> at 0x000001AA12F8BAC0>)\n\ntests\\unit\\test_shared_utils_init.py:456: AssertionError\n________ TestSharedUtilsInit.test_package_initialization_completeness _________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA1295B750>\n\n    def test_package_initialization_completeness(self):\n        \"\"\"Test that package initialization is complete and comprehensive.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n                                                        # Test that all core functions are available\n>                                                       assert hasattr(utils_package, 'get_logger')\nE                                                       AssertionError: assert False\nE                                                        +  where False = hasattr(<module 'shared.utils' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\utils\\\\__init__.py'>, 'get_logger')\n\ntests\\unit\\test_shared_utils_init.py:498: AssertionError\n______________ TestSharedUtilsInit.test_error_class_inheritance _______________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA1298C870>\n\n    def test_error_class_inheritance(self):\n        \"\"\"Test that error classes are properly defined and can be instantiated.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n                                                        # Test that error classes are exception types\n>                                                       assert issubclass(utils_package.CraftNudgeError, Exception)\n                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE                                                       AttributeError: module 'shared.utils' has no attribute 'CraftNudgeError'\n\ntests\\unit\\test_shared_utils_init.py:551: AttributeError\n_______________ TestSharedUtilsInit.test_function_availability ________________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA12933EC0>\n\n    def test_function_availability(self):\n        \"\"\"Test that all main functions are available and properly typed.\"\"\"\n        with patch('shared.utils.logger.get_logger') as mock_get_logger:\n            with patch('shared.utils.logger.setup_logger') as mock_setup_logger:\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error') as mock_handle_error:\n                                        with patch('shared.utils.error_handler.validate_required_fields') as mock_validate_required:\n                                            with patch('shared.utils.error_handler.validate_field_type') as mock_validate_type:\n                                                with patch('shared.utils.error_handler.safe_execute') as mock_safe_execute:\n                                                    with patch('shared.utils.error_handler.retry_on_error') as mock_retry_on_error:\n                                                        import shared.utils as utils_package\n    \n                                                        # Test that functions are callable\n>                                                       assert callable(utils_package.get_logger)\n                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^\nE                                                       AttributeError: module 'shared.utils' has no attribute 'get_logger'\n\ntests\\unit\\test_shared_utils_init.py:574: AttributeError\n________________ TestSharedUtilsInit.test_function_signatures _________________\n\nself = <unit.test_shared_utils_init.TestSharedUtilsInit object at 0x000001AA12992D50>\n\n    def test_function_signatures(self):\n        \"\"\"Test that all functions have the expected signatures.\"\"\"\n        with patch('shared.utils.logger.get_logger'):\n            with patch('shared.utils.logger.setup_logger'):\n                with patch('shared.utils.error_handler.CraftNudgeError'):\n                    with patch('shared.utils.error_handler.GitRepositoryError'):\n                        with patch('shared.utils.error_handler.DataStoreError'):\n                            with patch('shared.utils.error_handler.ValidationError'):\n                                with patch('shared.utils.error_handler.ConfigurationError'):\n                                    with patch('shared.utils.error_handler.handle_error'):\n                                        with patch('shared.utils.error_handler.validate_required_fields'):\n                                            with patch('shared.utils.error_handler.validate_field_type'):\n                                                with patch('shared.utils.error_handler.safe_execute'):\n                                                    with patch('shared.utils.error_handler.retry_on_error'):\n                                                        import shared.utils as utils_package\n    \n                                                        # Test that all functions are callable and have signatures\n                                                        import inspect\n    \n>                                                       assert inspect.isfunction(utils_package.get_logger)\n                                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^\nE                                                       AttributeError: module 'shared.utils' has no attribute 'get_logger'\n\ntests\\unit\\test_shared_utils_init.py:610: AttributeError\n_____________ TestSourceFileAnalysis.test_all_python_files_exist ______________\n\nself = <unit.test_source_files.TestSourceFileAnalysis object at 0x000001AA12984E10>\n\n    def test_all_python_files_exist(self):\n        \"\"\"Test that all expected Python files exist.\"\"\"\n        expected_files = [\n            \"track_commit.py\",\n            \"shared/config/config_manager.py\",\n            \"shared/utils/logger.py\",\n            \"shared/utils/error_handler.py\",\n            \"cli/commands/track_commit.py\",\n            \"cli/utils/cli_helpers.py\",\n            \"services/commit-tracker-service/src/commit_tracker.py\",\n            \"services/commit-tracker-service/src/git_parser.py\",\n            \"services/commit-tracker-service/src/data_writer.py\",\n            \"examples/basic_usage.py\"\n        ]\n    \n        for file_path in expected_files:\n            full_path = project_root / file_path\n>           assert full_path.exists(), f\"File {file_path} does not exist\"\nE           AssertionError: File track_commit.py does not exist\nE           assert False\nE            +  where False = exists()\nE            +    where exists = WindowsPath('C:/Projects/Pratice_Microservice/craftnudge-ai-agent/tests/track_commit.py').exists\n\ntests\\unit\\test_source_files.py:44: AssertionError\n____________ TestTrackCommitFile.test_track_commit_file_structure _____________\n\nself = <unit.test_source_files.TestTrackCommitFile object at 0x000001AA12984F50>\n\n    def test_track_commit_file_structure(self):\n        \"\"\"Test the structure of track_commit.py.\"\"\"\n        file_path = project_root / \"track_commit.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\track_commit.py'\n\ntests\\unit\\test_source_files.py:99: FileNotFoundError\n________________ TestTrackCommitFile.test_track_commit_imports ________________\n\nself = <unit.test_source_files.TestTrackCommitFile object at 0x000001AA12985090>\n\n    def test_track_commit_imports(self):\n        \"\"\"Test that track_commit.py has proper imports.\"\"\"\n        file_path = project_root / \"track_commit.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\track_commit.py'\n\ntests\\unit\\test_source_files.py:118: FileNotFoundError\n____________ TestConfigManager.test_config_manager_file_structure _____________\n\nself = <unit.test_source_files.TestConfigManager object at 0x000001AA129851D0>\n\n    def test_config_manager_file_structure(self):\n        \"\"\"Test the structure of config_manager.py.\"\"\"\n        file_path = project_root / \"shared\" / \"config\" / \"config_manager.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\shared\\\\config\\\\config_manager.py'\n\ntests\\unit\\test_source_files.py:134: FileNotFoundError\n________________ TestConfigManager.test_config_manager_imports ________________\n\nself = <unit.test_source_files.TestConfigManager object at 0x000001AA12985310>\n\n    def test_config_manager_imports(self):\n        \"\"\"Test that config_manager.py has proper imports.\"\"\"\n        file_path = project_root / \"shared\" / \"config\" / \"config_manager.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\shared\\\\config\\\\config_manager.py'\n\ntests\\unit\\test_source_files.py:151: FileNotFoundError\n_______________ TestConfigManager.test_config_manager_functions _______________\n\nself = <unit.test_source_files.TestConfigManager object at 0x000001AA12807E10>\n\n    def test_config_manager_functions(self):\n        \"\"\"Test config manager functions with mocks.\"\"\"\n        with patch('shared.config.config_manager.yaml') as mock_yaml:\n>           with patch('shared.config.config_manager.logging') as mock_logging:\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_source_files.py:163: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA13140680>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'shared.config.config_manager' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\config\\\\config_manager.py'> does not have the attribute 'logging'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n____________________ TestLogger.test_logger_file_structure ____________________\n\nself = <unit.test_source_files.TestLogger object at 0x000001AA12985450>\n\n    def test_logger_file_structure(self):\n        \"\"\"Test the structure of logger.py.\"\"\"\n        file_path = project_root / \"shared\" / \"utils\" / \"logger.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\shared\\\\utils\\\\logger.py'\n\ntests\\unit\\test_source_files.py:203: FileNotFoundError\n_______________________ TestLogger.test_logger_imports ________________________\n\nself = <unit.test_source_files.TestLogger object at 0x000001AA12985590>\n\n    def test_logger_imports(self):\n        \"\"\"Test that logger.py has proper imports.\"\"\"\n        file_path = project_root / \"shared\" / \"utils\" / \"logger.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\shared\\\\utils\\\\logger.py'\n\ntests\\unit\\test_source_files.py:215: FileNotFoundError\n_____________ TestErrorHandler.test_error_handler_file_structure ______________\n\nself = <unit.test_source_files.TestErrorHandler object at 0x000001AA129856D0>\n\n    def test_error_handler_file_structure(self):\n        \"\"\"Test the structure of error_handler.py.\"\"\"\n        file_path = project_root / \"shared\" / \"utils\" / \"error_handler.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\shared\\\\utils\\\\error_handler.py'\n\ntests\\unit\\test_source_files.py:250: FileNotFoundError\n_________________ TestErrorHandler.test_error_handler_imports _________________\n\nself = <unit.test_source_files.TestErrorHandler object at 0x000001AA12985810>\n\n    def test_error_handler_imports(self):\n        \"\"\"Test that error_handler.py has proper imports.\"\"\"\n        file_path = project_root / \"shared\" / \"utils\" / \"error_handler.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\shared\\\\utils\\\\error_handler.py'\n\ntests\\unit\\test_source_files.py:271: FileNotFoundError\n_________________ TestErrorHandler.test_error_handler_classes _________________\n\nself = <unit.test_source_files.TestErrorHandler object at 0x000001AA129C0180>\n\n    def test_error_handler_classes(self):\n        \"\"\"Test error handler classes with mocks.\"\"\"\n        # Test CraftNudgeError\n>       with patch('shared.utils.error_handler.logging') as mock_logging:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_source_files.py:283: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA13141390>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'shared.utils.error_handler' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\utils\\\\error_handler.py'> does not have the attribute 'logging'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n________________ TestErrorHandler.test_error_handler_functions ________________\n\nself = <unit.test_source_files.TestErrorHandler object at 0x000001AA129C02B0>\n\n    def test_error_handler_functions(self):\n        \"\"\"Test error handler functions with mocks.\"\"\"\n>       with patch('shared.utils.error_handler.logging') as mock_logging:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_source_files.py:297: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA13141650>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'shared.utils.error_handler' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\shared\\\\utils\\\\error_handler.py'> does not have the attribute 'logging'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n______________ TestCLICommands.test_cli_commands_file_structure _______________\n\nself = <unit.test_source_files.TestCLICommands object at 0x000001AA12985950>\n\n    def test_cli_commands_file_structure(self):\n        \"\"\"Test the structure of track_commit.py in CLI commands.\"\"\"\n        file_path = project_root / \"cli\" / \"commands\" / \"track_commit.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\cli\\\\commands\\\\track_commit.py'\n\ntests\\unit\\test_source_files.py:327: FileNotFoundError\n__________________ TestCLICommands.test_cli_commands_imports __________________\n\nself = <unit.test_source_files.TestCLICommands object at 0x000001AA12985A90>\n\n    def test_cli_commands_imports(self):\n        \"\"\"Test that CLI commands have proper imports.\"\"\"\n        file_path = project_root / \"cli\" / \"commands\" / \"track_commit.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\cli\\\\commands\\\\track_commit.py'\n\ntests\\unit\\test_source_files.py:339: FileNotFoundError\n____________ TestCommitTracker.test_commit_tracker_file_structure _____________\n\nself = <unit.test_source_files.TestCommitTracker object at 0x000001AA12985BD0>\n\n    def test_commit_tracker_file_structure(self):\n        \"\"\"Test the structure of commit_tracker.py.\"\"\"\n        file_path = project_root / \"services\" / \"commit-tracker-service\" / \"src\" / \"commit_tracker.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\services\\\\commit-tracker-service\\\\src\\\\commit_tracker.py'\n\ntests\\unit\\test_source_files.py:374: FileNotFoundError\n________________ TestCommitTracker.test_commit_tracker_imports ________________\n\nself = <unit.test_source_files.TestCommitTracker object at 0x000001AA12985D10>\n\n    def test_commit_tracker_imports(self):\n        \"\"\"Test that commit_tracker.py has proper imports.\"\"\"\n        file_path = project_root / \"services\" / \"commit-tracker-service\" / \"src\" / \"commit_tracker.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\services\\\\commit-tracker-service\\\\src\\\\commit_tracker.py'\n\ntests\\unit\\test_source_files.py:389: FileNotFoundError\n_________________ TestCommitTracker.test_commit_tracker_class _________________\n\nself = <unit.test_source_files.TestCommitTracker object at 0x000001AA129C0510>\n\n    def test_commit_tracker_class(self):\n        \"\"\"Test commit tracker class with mocks.\"\"\"\n>       with patch('services.commit_tracker_service.src.commit_tracker.logging') as mock_logging:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_source_files.py:399: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA13142410>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'services.commit_tracker_service.src.commit_tracker' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\services\\\\commit_tracker_service\\\\src\\\\commit_tracker.py'> does not have the attribute 'logging'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n________________ TestGitParser.test_git_parser_file_structure _________________\n\nself = <unit.test_source_files.TestGitParser object at 0x000001AA12985E50>\n\n    def test_git_parser_file_structure(self):\n        \"\"\"Test the structure of git_parser.py.\"\"\"\n        file_path = project_root / \"services\" / \"commit-tracker-service\" / \"src\" / \"git_parser.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\services\\\\commit-tracker-service\\\\src\\\\git_parser.py'\n\ntests\\unit\\test_source_files.py:426: FileNotFoundError\n____________________ TestGitParser.test_git_parser_imports ____________________\n\nself = <unit.test_source_files.TestGitParser object at 0x000001AA12985F90>\n\n    def test_git_parser_imports(self):\n        \"\"\"Test that git_parser.py has proper imports.\"\"\"\n        file_path = project_root / \"services\" / \"commit-tracker-service\" / \"src\" / \"git_parser.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\services\\\\commit-tracker-service\\\\src\\\\git_parser.py'\n\ntests\\unit\\test_source_files.py:442: FileNotFoundError\n_______________ TestDataWriter.test_data_writer_file_structure ________________\n\nself = <unit.test_source_files.TestDataWriter object at 0x000001AA129860D0>\n\n    def test_data_writer_file_structure(self):\n        \"\"\"Test the structure of data_writer.py.\"\"\"\n        file_path = project_root / \"services\" / \"commit-tracker-service\" / \"src\" / \"data_writer.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\services\\\\commit-tracker-service\\\\src\\\\data_writer.py'\n\ntests\\unit\\test_source_files.py:478: FileNotFoundError\n___________________ TestDataWriter.test_data_writer_imports ___________________\n\nself = <unit.test_source_files.TestDataWriter object at 0x000001AA12986210>\n\n    def test_data_writer_imports(self):\n        \"\"\"Test that data_writer.py has proper imports.\"\"\"\n        file_path = project_root / \"services\" / \"commit-tracker-service\" / \"src\" / \"data_writer.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\services\\\\commit-tracker-service\\\\src\\\\data_writer.py'\n\ntests\\unit\\test_source_files.py:493: FileNotFoundError\n_______________ TestBasicUsage.test_basic_usage_file_structure ________________\n\nself = <unit.test_source_files.TestBasicUsage object at 0x000001AA12986350>\n\n    def test_basic_usage_file_structure(self):\n        \"\"\"Test the structure of basic_usage.py.\"\"\"\n        file_path = project_root / \"examples\" / \"basic_usage.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\examples\\\\basic_usage.py'\n\ntests\\unit\\test_source_files.py:529: FileNotFoundError\n___________________ TestBasicUsage.test_basic_usage_imports ___________________\n\nself = <unit.test_source_files.TestBasicUsage object at 0x000001AA12986490>\n\n    def test_basic_usage_imports(self):\n        \"\"\"Test that basic_usage.py has proper imports.\"\"\"\n        file_path = project_root / \"examples\" / \"basic_usage.py\"\n    \n>       with open(file_path, 'r', encoding='utf-8') as f:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\examples\\\\basic_usage.py'\n\ntests\\unit\\test_source_files.py:542: FileNotFoundError\n____________________ TestIntegration.test_cli_integration _____________________\n\nself = <unit.test_source_files.TestIntegration object at 0x000001AA129C09D0>\n\n    def test_cli_integration(self):\n        \"\"\"Test CLI integration.\"\"\"\n        with patch('cli.commands.track_commit.main') as mock_main:\n>           with patch('cli.commands.track_commit.track_commit') as mock_track_commit:\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_source_files.py:601: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA13143D80>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'cli.commands.track_commit' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\commands\\\\track_commit.py'> does not have the attribute 'track_commit'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n___________________ TestCoverage.test_all_functions_covered ___________________\n\nself = <unit.test_source_files.TestCoverage object at 0x000001AA12986850>\n\n    def test_all_functions_covered(self):\n        \"\"\"Test that all functions are covered by tests.\"\"\"\n        # This test ensures that all the functions we've tested are actually\n        # present in the source files\n        expected_functions = [\n            \"main\",\n            \"get_config\",\n            \"get_config_value\",\n            \"reload_config\",\n            \"update_config\",\n            \"create_default_config\",\n            \"load_config_file\",\n            \"validate_config\",\n            \"deep_merge\",\n            \"setup_logger\",\n            \"get_logger\",\n            \"handle_error\",\n            \"validate_required_fields\",\n            \"validate_field_type\",\n            \"safe_execute\",\n            \"retry_on_error\",\n            \"track_commit\",\n            \"parse_arguments\"\n        ]\n    \n        # Check that functions exist in their respective files\n        function_file_mapping = {\n            \"main\": [\"track_commit.py\", \"cli/commands/track_commit.py\", \"examples/basic_usage.py\"],\n            \"get_config\": [\"shared/config/config_manager.py\"],\n            \"get_config_value\": [\"shared/config/config_manager.py\"],\n            \"reload_config\": [\"shared/config/config_manager.py\"],\n            \"update_config\": [\"shared/config/config_manager.py\"],\n            \"create_default_config\": [\"shared/config/config_manager.py\"],\n            \"load_config_file\": [\"shared/config/config_manager.py\"],\n            \"validate_config\": [\"shared/config/config_manager.py\"],\n            \"deep_merge\": [\"shared/config/config_manager.py\"],\n            \"setup_logger\": [\"shared/utils/logger.py\"],\n            \"get_logger\": [\"shared/utils/logger.py\"],\n            \"handle_error\": [\"shared/utils/error_handler.py\"],\n            \"validate_required_fields\": [\"shared/utils/error_handler.py\"],\n            \"validate_field_type\": [\"shared/utils/error_handler.py\"],\n            \"safe_execute\": [\"shared/utils/error_handler.py\"],\n            \"retry_on_error\": [\"shared/utils/error_handler.py\"],\n            \"track_commit\": [\"cli/commands/track_commit.py\"],\n            \"parse_arguments\": [\"cli/commands/track_commit.py\"]\n        }\n    \n        for function_name, file_paths in function_file_mapping.items():\n            found = False\n            for file_path in file_paths:\n                full_path = project_root / file_path\n>               with open(full_path, 'r', encoding='utf-8') as f:\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE               FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\track_commit.py'\n\ntests\\unit\\test_source_files.py:732: FileNotFoundError\n____________________ TestCoverage.test_all_classes_covered ____________________\n\nself = <unit.test_source_files.TestCoverage object at 0x000001AA12986990>\n\n    def test_all_classes_covered(self):\n        \"\"\"Test that all classes are covered by tests.\"\"\"\n        # This test ensures that all the classes we've tested are actually\n        # present in the source files\n        expected_classes = [\n            \"CraftNudgeError\",\n            \"GitRepositoryError\",\n            \"DataStoreError\",\n            \"ValidationError\",\n            \"ConfigurationError\",\n            \"InterceptHandler\",\n            \"CommitTracker\",\n            \"GitParser\",\n            \"GitCommandError\",\n            \"DataWriter\"\n        ]\n    \n        # Check that classes exist in their respective files\n        class_file_mapping = {\n            \"CraftNudgeError\": \"shared/utils/error_handler.py\",\n            \"GitRepositoryError\": \"shared/utils/error_handler.py\",\n            \"DataStoreError\": \"shared/utils/error_handler.py\",\n            \"ValidationError\": \"shared/utils/error_handler.py\",\n            \"ConfigurationError\": \"shared/utils/error_handler.py\",\n            \"InterceptHandler\": \"shared/utils/logger.py\",\n            \"CommitTracker\": \"services/commit-tracker-service/src/commit_tracker.py\",\n            \"GitParser\": \"services/commit-tracker-service/src/git_parser.py\",\n            \"GitCommandError\": \"services/commit-tracker-service/src/git_parser.py\",\n            \"DataWriter\": \"services/commit-tracker-service/src/data_writer.py\"\n        }\n    \n        for class_name, file_path in class_file_mapping.items():\n            full_path = project_root / file_path\n>           with open(full_path, 'r', encoding='utf-8') as f:\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\tests\\\\shared\\\\utils\\\\error_handler.py'\n\ntests\\unit\\test_source_files.py:677: FileNotFoundError\n_______________ TestArgumentParser.test_parser_has_subcommands ________________\n\nself = <unit.test_track_commit_cli.TestArgumentParser object at 0x000001AA129C0C30>\n\n    def test_parser_has_subcommands(self):\n        \"\"\"Test parser has all required subcommands.\"\"\"\n        parser = create_argument_parser()\n    \n        # Check subcommands exist\n>       subcommands = [action.dest for action in parser._subparsers._group_actions[0].choices.values()]\n                       ^^^^^^^^^^^\nE       AttributeError: 'ArgumentParser' object has no attribute 'dest'\n\ntests\\unit\\test_track_commit_cli.py:48: AttributeError\n________________ TestArgumentParser.test_latest_command_parser ________________\n\nself = <unit.test_track_commit_cli.TestArgumentParser object at 0x000001AA129C0D60>\n\n    def test_latest_command_parser(self):\n        \"\"\"Test latest command parser.\"\"\"\n        parser = create_argument_parser()\n        latest_parser = parser._subparsers._group_actions[0].choices['latest']\n    \n        # Latest command should not have additional arguments\n>       assert len(latest_parser._optionals._group_actions) == 0\nE       AssertionError: assert 1 == 0\nE        +  where 1 = len([_HelpAction(option_strings=['-h', '--help'], dest='help', nargs=0, const=None, default='==SUPPRESS==', type=None, choices=None, required=False, help='show this help message and exit', metavar=None, deprecated=False)])\nE        +    where [_HelpAction(option_strings=['-h', '--help'], dest='help', nargs=0, const=None, default='==SUPPRESS==', type=None, choices=None, required=False, help='show this help message and exit', metavar=None, deprecated=False)] = <argparse._ArgumentGroup object at 0x000001AA13271790>._group_actions\nE        +      where <argparse._ArgumentGroup object at 0x000001AA13271790> = ArgumentParser(prog='__main__.py latest', usage=None, description=None, formatter_class=<class 'argparse.HelpFormatter'>, conflict_handler='error', add_help=True)._optionals\n\ntests\\unit\\test_track_commit_cli.py:60: AssertionError\n_____________ TestArgumentParser.test_output_format_choices[json] _____________\n\nself = <unit.test_track_commit_cli.TestArgumentParser object at 0x000001AA129DD450>\noutput_format = 'json'\n\n    @pytest.mark.parametrize(\"output_format\", ['json', 'text', 'table'])\n    def test_output_format_choices(self, output_format):\n        \"\"\"Test output format choices are valid.\"\"\"\n        parser = create_argument_parser()\n    \n        # Parse with different output formats\n>       args = parser.parse_args(['latest', '--output-format', output_format])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_track_commit_cli.py:95: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\argparse.py:1902: in parse_args\n    self.error(msg)\nC:\\Python313\\Lib\\argparse.py:2658: in error\n    self.exit(2, _('%(prog)s: error: %(message)s\\n') % args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ArgumentParser(prog='__main__.py', usage=None, description='Track Git commits for behavioral analysis', formatter_class=<class 'argparse.RawDescriptionHelpFormatter'>, conflict_handler='error', add_help=True)\nstatus = 2\nmessage = '__main__.py: error: unrecognized arguments: --output-format json\\n'\n\n    def exit(self, status=0, message=None):\n        if message:\n            self._print_message(message, _sys.stderr)\n>       _sys.exit(status)\nE       SystemExit: 2\n\nC:\\Python313\\Lib\\argparse.py:2645: SystemExit\n---------------------------- Captured stderr call -----------------------------\nusage: __main__.py [-h] [--repo-path REPO_PATH]\n                   [--output-format {json,text,table}] [--verbose]\n                   [--log-level {DEBUG,INFO,WARNING,ERROR}]\n                   [--log-file LOG_FILE]\n                   {latest,hash,info,list,search} ...\n__main__.py: error: unrecognized arguments: --output-format json\n_____________ TestArgumentParser.test_output_format_choices[text] _____________\n\nself = <unit.test_track_commit_cli.TestArgumentParser object at 0x000001AA129DD550>\noutput_format = 'text'\n\n    @pytest.mark.parametrize(\"output_format\", ['json', 'text', 'table'])\n    def test_output_format_choices(self, output_format):\n        \"\"\"Test output format choices are valid.\"\"\"\n        parser = create_argument_parser()\n    \n        # Parse with different output formats\n>       args = parser.parse_args(['latest', '--output-format', output_format])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_track_commit_cli.py:95: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\argparse.py:1902: in parse_args\n    self.error(msg)\nC:\\Python313\\Lib\\argparse.py:2658: in error\n    self.exit(2, _('%(prog)s: error: %(message)s\\n') % args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ArgumentParser(prog='__main__.py', usage=None, description='Track Git commits for behavioral analysis', formatter_class=<class 'argparse.RawDescriptionHelpFormatter'>, conflict_handler='error', add_help=True)\nstatus = 2\nmessage = '__main__.py: error: unrecognized arguments: --output-format text\\n'\n\n    def exit(self, status=0, message=None):\n        if message:\n            self._print_message(message, _sys.stderr)\n>       _sys.exit(status)\nE       SystemExit: 2\n\nC:\\Python313\\Lib\\argparse.py:2645: SystemExit\n---------------------------- Captured stderr call -----------------------------\nusage: __main__.py [-h] [--repo-path REPO_PATH]\n                   [--output-format {json,text,table}] [--verbose]\n                   [--log-level {DEBUG,INFO,WARNING,ERROR}]\n                   [--log-file LOG_FILE]\n                   {latest,hash,info,list,search} ...\n__main__.py: error: unrecognized arguments: --output-format text\n____________ TestArgumentParser.test_output_format_choices[table] _____________\n\nself = <unit.test_track_commit_cli.TestArgumentParser object at 0x000001AA128863F0>\noutput_format = 'table'\n\n    @pytest.mark.parametrize(\"output_format\", ['json', 'text', 'table'])\n    def test_output_format_choices(self, output_format):\n        \"\"\"Test output format choices are valid.\"\"\"\n        parser = create_argument_parser()\n    \n        # Parse with different output formats\n>       args = parser.parse_args(['latest', '--output-format', output_format])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_track_commit_cli.py:95: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\argparse.py:1902: in parse_args\n    self.error(msg)\nC:\\Python313\\Lib\\argparse.py:2658: in error\n    self.exit(2, _('%(prog)s: error: %(message)s\\n') % args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ArgumentParser(prog='__main__.py', usage=None, description='Track Git commits for behavioral analysis', formatter_class=<class 'argparse.RawDescriptionHelpFormatter'>, conflict_handler='error', add_help=True)\nstatus = 2\nmessage = '__main__.py: error: unrecognized arguments: --output-format table\\n'\n\n    def exit(self, status=0, message=None):\n        if message:\n            self._print_message(message, _sys.stderr)\n>       _sys.exit(status)\nE       SystemExit: 2\n\nC:\\Python313\\Lib\\argparse.py:2645: SystemExit\n---------------------------- Captured stderr call -----------------------------\nusage: __main__.py [-h] [--repo-path REPO_PATH]\n                   [--output-format {json,text,table}] [--verbose]\n                   [--log-level {DEBUG,INFO,WARNING,ERROR}]\n                   [--log-file LOG_FILE]\n                   {latest,hash,info,list,search} ...\n__main__.py: error: unrecognized arguments: --output-format table\n______________ TestArgumentParser.test_log_level_choices[DEBUG] _______________\n\nself = <unit.test_track_commit_cli.TestArgumentParser object at 0x000001AA12886300>\nlog_level = 'DEBUG'\n\n    @pytest.mark.parametrize(\"log_level\", ['DEBUG', 'INFO', 'WARNING', 'ERROR'])\n    def test_log_level_choices(self, log_level):\n        \"\"\"Test log level choices are valid.\"\"\"\n        parser = create_argument_parser()\n    \n        # Parse with different log levels\n>       args = parser.parse_args(['latest', '--log-level', log_level])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_track_commit_cli.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\argparse.py:1902: in parse_args\n    self.error(msg)\nC:\\Python313\\Lib\\argparse.py:2658: in error\n    self.exit(2, _('%(prog)s: error: %(message)s\\n') % args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ArgumentParser(prog='__main__.py', usage=None, description='Track Git commits for behavioral analysis', formatter_class=<class 'argparse.RawDescriptionHelpFormatter'>, conflict_handler='error', add_help=True)\nstatus = 2\nmessage = '__main__.py: error: unrecognized arguments: --log-level DEBUG\\n'\n\n    def exit(self, status=0, message=None):\n        if message:\n            self._print_message(message, _sys.stderr)\n>       _sys.exit(status)\nE       SystemExit: 2\n\nC:\\Python313\\Lib\\argparse.py:2645: SystemExit\n---------------------------- Captured stderr call -----------------------------\nusage: __main__.py [-h] [--repo-path REPO_PATH]\n                   [--output-format {json,text,table}] [--verbose]\n                   [--log-level {DEBUG,INFO,WARNING,ERROR}]\n                   [--log-file LOG_FILE]\n                   {latest,hash,info,list,search} ...\n__main__.py: error: unrecognized arguments: --log-level DEBUG\n_______________ TestArgumentParser.test_log_level_choices[INFO] _______________\n\nself = <unit.test_track_commit_cli.TestArgumentParser object at 0x000001AA129499B0>\nlog_level = 'INFO'\n\n    @pytest.mark.parametrize(\"log_level\", ['DEBUG', 'INFO', 'WARNING', 'ERROR'])\n    def test_log_level_choices(self, log_level):\n        \"\"\"Test log level choices are valid.\"\"\"\n        parser = create_argument_parser()\n    \n        # Parse with different log levels\n>       args = parser.parse_args(['latest', '--log-level', log_level])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_track_commit_cli.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\argparse.py:1902: in parse_args\n    self.error(msg)\nC:\\Python313\\Lib\\argparse.py:2658: in error\n    self.exit(2, _('%(prog)s: error: %(message)s\\n') % args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ArgumentParser(prog='__main__.py', usage=None, description='Track Git commits for behavioral analysis', formatter_class=<class 'argparse.RawDescriptionHelpFormatter'>, conflict_handler='error', add_help=True)\nstatus = 2\nmessage = '__main__.py: error: unrecognized arguments: --log-level INFO\\n'\n\n    def exit(self, status=0, message=None):\n        if message:\n            self._print_message(message, _sys.stderr)\n>       _sys.exit(status)\nE       SystemExit: 2\n\nC:\\Python313\\Lib\\argparse.py:2645: SystemExit\n---------------------------- Captured stderr call -----------------------------\nusage: __main__.py [-h] [--repo-path REPO_PATH]\n                   [--output-format {json,text,table}] [--verbose]\n                   [--log-level {DEBUG,INFO,WARNING,ERROR}]\n                   [--log-file LOG_FILE]\n                   {latest,hash,info,list,search} ...\n__main__.py: error: unrecognized arguments: --log-level INFO\n_____________ TestArgumentParser.test_log_level_choices[WARNING] ______________\n\nself = <unit.test_track_commit_cli.TestArgumentParser object at 0x000001AA12948D70>\nlog_level = 'WARNING'\n\n    @pytest.mark.parametrize(\"log_level\", ['DEBUG', 'INFO', 'WARNING', 'ERROR'])\n    def test_log_level_choices(self, log_level):\n        \"\"\"Test log level choices are valid.\"\"\"\n        parser = create_argument_parser()\n    \n        # Parse with different log levels\n>       args = parser.parse_args(['latest', '--log-level', log_level])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_track_commit_cli.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\argparse.py:1902: in parse_args\n    self.error(msg)\nC:\\Python313\\Lib\\argparse.py:2658: in error\n    self.exit(2, _('%(prog)s: error: %(message)s\\n') % args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ArgumentParser(prog='__main__.py', usage=None, description='Track Git commits for behavioral analysis', formatter_class=<class 'argparse.RawDescriptionHelpFormatter'>, conflict_handler='error', add_help=True)\nstatus = 2\nmessage = '__main__.py: error: unrecognized arguments: --log-level WARNING\\n'\n\n    def exit(self, status=0, message=None):\n        if message:\n            self._print_message(message, _sys.stderr)\n>       _sys.exit(status)\nE       SystemExit: 2\n\nC:\\Python313\\Lib\\argparse.py:2645: SystemExit\n---------------------------- Captured stderr call -----------------------------\nusage: __main__.py [-h] [--repo-path REPO_PATH]\n                   [--output-format {json,text,table}] [--verbose]\n                   [--log-level {DEBUG,INFO,WARNING,ERROR}]\n                   [--log-file LOG_FILE]\n                   {latest,hash,info,list,search} ...\n__main__.py: error: unrecognized arguments: --log-level WARNING\n______________ TestArgumentParser.test_log_level_choices[ERROR] _______________\n\nself = <unit.test_track_commit_cli.TestArgumentParser object at 0x000001AA128CF450>\nlog_level = 'ERROR'\n\n    @pytest.mark.parametrize(\"log_level\", ['DEBUG', 'INFO', 'WARNING', 'ERROR'])\n    def test_log_level_choices(self, log_level):\n        \"\"\"Test log level choices are valid.\"\"\"\n        parser = create_argument_parser()\n    \n        # Parse with different log levels\n>       args = parser.parse_args(['latest', '--log-level', log_level])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_track_commit_cli.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\argparse.py:1902: in parse_args\n    self.error(msg)\nC:\\Python313\\Lib\\argparse.py:2658: in error\n    self.exit(2, _('%(prog)s: error: %(message)s\\n') % args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ArgumentParser(prog='__main__.py', usage=None, description='Track Git commits for behavioral analysis', formatter_class=<class 'argparse.RawDescriptionHelpFormatter'>, conflict_handler='error', add_help=True)\nstatus = 2\nmessage = '__main__.py: error: unrecognized arguments: --log-level ERROR\\n'\n\n    def exit(self, status=0, message=None):\n        if message:\n            self._print_message(message, _sys.stderr)\n>       _sys.exit(status)\nE       SystemExit: 2\n\nC:\\Python313\\Lib\\argparse.py:2645: SystemExit\n---------------------------- Captured stderr call -----------------------------\nusage: __main__.py [-h] [--repo-path REPO_PATH]\n                   [--output-format {json,text,table}] [--verbose]\n                   [--log-level {DEBUG,INFO,WARNING,ERROR}]\n                   [--log-file LOG_FILE]\n                   {latest,hash,info,list,search} ...\n__main__.py: error: unrecognized arguments: --log-level ERROR\n_____________________ TestCLIFunctions.test_list_commits ______________________\n\nargs = (<unit.test_track_commit_cli.TestCLIFunctions object at 0x000001AA129C0FC0>,)\nkeywargs = {}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n>       with self.decoration_helper(patched,\n                                    args,\n                                    keywargs) as (newargs, newkeywargs):\n\nC:\\Python313\\Lib\\unittest\\mock.py:1423: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\contextlib.py:141: in __enter__\n    return next(self.gen)\n           ^^^^^^^^^^^^^^\nC:\\Python313\\Lib\\unittest\\mock.py:1405: in decoration_helper\n    arg = exit_stack.enter_context(patching)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Python313\\Lib\\contextlib.py:530: in enter_context\n    result = _enter(cm)\n             ^^^^^^^^^^\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA128FFE30>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'cli.commands.track_commit' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\commands\\\\track_commit.py'> does not have the attribute 'DataWriter'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n_____________ TestCLIFunctions.test_search_commits_with_criteria ______________\n\nargs = (<unit.test_track_commit_cli.TestCLIFunctions object at 0x000001AA129D5B50>,)\nkeywargs = {}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n>       with self.decoration_helper(patched,\n                                    args,\n                                    keywargs) as (newargs, newkeywargs):\n\nC:\\Python313\\Lib\\unittest\\mock.py:1423: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\contextlib.py:141: in __enter__\n    return next(self.gen)\n           ^^^^^^^^^^^^^^\nC:\\Python313\\Lib\\unittest\\mock.py:1405: in decoration_helper\n    arg = exit_stack.enter_context(patching)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Python313\\Lib\\contextlib.py:530: in enter_context\n    result = _enter(cm)\n             ^^^^^^^^^^\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA128FFEE0>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'cli.commands.track_commit' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\commands\\\\track_commit.py'> does not have the attribute 'DataWriter'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n____________ TestCLIFunctions.test_search_commits_without_criteria ____________\n\nargs = (<unit.test_track_commit_cli.TestCLIFunctions object at 0x000001AA128DACF0>,)\nkeywargs = {}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n>       with self.decoration_helper(patched,\n                                    args,\n                                    keywargs) as (newargs, newkeywargs):\n\nC:\\Python313\\Lib\\unittest\\mock.py:1423: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\contextlib.py:141: in __enter__\n    return next(self.gen)\n           ^^^^^^^^^^^^^^\nC:\\Python313\\Lib\\unittest\\mock.py:1405: in decoration_helper\n    arg = exit_stack.enter_context(patching)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Python313\\Lib\\contextlib.py:530: in enter_context\n    result = _enter(cm)\n             ^^^^^^^^^^\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA129F8050>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'cli.commands.track_commit' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\commands\\\\track_commit.py'> does not have the attribute 'DataWriter'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n_____________ TestCLIFunctions.test_search_commits_applies_limit ______________\n\nargs = (<unit.test_track_commit_cli.TestCLIFunctions object at 0x000001AA128DAE00>,)\nkeywargs = {}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n>       with self.decoration_helper(patched,\n                                    args,\n                                    keywargs) as (newargs, newkeywargs):\n\nC:\\Python313\\Lib\\unittest\\mock.py:1423: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\contextlib.py:141: in __enter__\n    return next(self.gen)\n           ^^^^^^^^^^^^^^\nC:\\Python313\\Lib\\unittest\\mock.py:1405: in decoration_helper\n    arg = exit_stack.enter_context(patching)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Python313\\Lib\\contextlib.py:530: in enter_context\n    result = _enter(cm)\n             ^^^^^^^^^^\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA129F8100>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'cli.commands.track_commit' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\commands\\\\track_commit.py'> does not have the attribute 'DataWriter'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n__________ TestOutputFunctions.test_output_text_result_commits_list ___________\n\nself = <unit.test_track_commit_cli.TestOutputFunctions object at 0x000001AA129DD650>\nmock_print = <MagicMock name='print' id='1829972906672'>\n\n    @patch('builtins.print')\n    def test_output_text_result_commits_list(self, mock_print):\n        \"\"\"Test output_text_result with commits list.\"\"\"\n        result = {\n            'status': 'success',\n            'message': 'Found 2 commits',\n            'commits': [\n                {\n                    'hash': 'abc123def456',\n                    'author': 'Author 1',\n                    'message': 'Commit 1',\n                    'commit_date': '2023-01-01T12:00:00+00:00',\n                    'changed_files': ['file1.py']\n                },\n                {\n                    'hash': 'def456ghi789',\n                    'author': 'Author 2',\n                    'message': 'Commit 2',\n                    'commit_date': '2023-01-02T12:00:00+00:00',\n                    'changed_files': ['file2.py', 'file3.py']\n                }\n            ]\n        }\n    \n        output_text_result(result, False)\n    \n        # Verify commits list was printed\n        print_calls = [call[0][0] for call in mock_print.call_args_list]\n        assert any(\"\\u2705 Found 2 commits\" in call for call in print_calls)\n>       assert any(\"1. Commit: abc123def\" in call for call in print_calls)\nE       assert False\nE        +  where False = any(<generator object TestOutputFunctions.test_output_text_result_commits_list.<locals>.<genexpr> at 0x000001AA1301BE00>)\n\ntests\\unit\\test_track_commit_cli.py:399: AssertionError\n__________ TestOutputFunctions.test_output_table_result_no_tabulate ___________\n\nself = <unit.test_track_commit_cli.TestOutputFunctions object at 0x000001AA128864E0>\nmock_print = <MagicMock name='print' id='1829972907344'>\n\n    @patch('builtins.print')\n    def test_output_table_result_no_tabulate(self, mock_print):\n        \"\"\"Test output_table_result when tabulate is not available.\"\"\"\n        result = {'status': 'success', 'message': 'Test message'}\n    \n>       with patch('cli.commands.track_commit.tabulate', side_effect=ImportError):\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_track_commit_cli.py:423: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA13109BD0>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'cli.commands.track_commit' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\commands\\\\track_commit.py'> does not have the attribute 'tabulate'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n__________ TestOutputFunctions.test_output_table_result_with_commits __________\n\nself = <unit.test_track_commit_cli.TestOutputFunctions object at 0x000001AA128865D0>\nmock_print = <MagicMock name='print' id='1829972906336'>\n\n    @patch('builtins.print')\n    def test_output_table_result_with_commits(self, mock_print):\n        \"\"\"Test output_table_result with commits data.\"\"\"\n        result = {\n            'status': 'success',\n            'message': 'Found 2 commits',\n            'commits': [\n                {\n                    'hash': 'abc123def456',\n                    'author': 'Author 1',\n                    'message': 'Commit 1',\n                    'commit_date': '2023-01-01T12:00:00+00:00',\n                    'changed_files': ['file1.py']\n                },\n                {\n                    'hash': 'def456ghi789',\n                    'author': 'Author 2',\n                    'message': 'Commit 2',\n                    'commit_date': '2023-01-02T12:00:00+00:00',\n                    'changed_files': ['file2.py', 'file3.py']\n                }\n            ]\n        }\n    \n        mock_tabulate = MagicMock()\n        mock_tabulate.return_value = \"Mock table output\"\n    \n>       with patch('cli.commands.track_commit.tabulate', mock_tabulate):\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\unit\\test_track_commit_cli.py:456: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Python313\\Lib\\unittest\\mock.py:1497: in __enter__\n    original, local = self.get_original()\n                      ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000001AA1310BCD0>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <module 'cli.commands.track_commit' from 'C:\\\\Projects\\\\Pratice_Microservice\\\\craftnudge-ai-agent\\\\cli\\\\commands\\\\track_commit.py'> does not have the attribute 'tabulate'\n\nC:\\Python313\\Lib\\unittest\\mock.py:1467: AttributeError\n_________________ TestMainFunction.test_main_unknown_command __________________\n\nself = <unit.test_track_commit_cli.TestMainFunction object at 0x000001AA128DB130>\nmock_exit = <MagicMock name='exit' id='1829970114080'>\nmock_parser = <MagicMock name='create_argument_parser' id='1829970110720'>\nmock_tracker_class = <MagicMock name='CommitTracker' id='1829970109712'>\nmock_setup_logger = <MagicMock name='setup_logger' id='1829970101312'>\nmock_output_result = <MagicMock name='output_result' id='1829970107024'>\n\n    @patch('cli.commands.track_commit.output_result')\n    @patch('cli.commands.track_commit.setup_logger')\n    @patch('cli.commands.track_commit.CommitTracker')\n    @patch('cli.commands.track_commit.create_argument_parser')\n    @patch('cli.commands.track_commit.sys.exit')\n    def test_main_unknown_command(self, mock_exit, mock_parser, mock_tracker_class, mock_setup_logger, mock_output_result):\n        \"\"\"Test main function with unknown command.\"\"\"\n        # Mock argument parser\n        mock_parser_instance = MagicMock()\n        mock_parser.return_value = mock_parser_instance\n    \n        mock_args = MagicMock()\n        mock_args.command = 'unknown'\n        mock_args.repo_path = None\n        mock_args.output_format = 'text'\n        mock_args.verbose = False\n        mock_args.log_level = 'INFO'\n        mock_args.log_file = None\n        mock_parser_instance.parse_args.return_value = mock_args\n    \n        # Mock sys.argv\n        with patch('sys.argv', ['track_commit.py', 'unknown']):\n            main()\n    \n        # Verify help was printed and exit called\n        mock_parser_instance.print_help.assert_called_once()\n>       mock_exit.assert_called_once_with(1)\n\ntests\\unit\\test_track_commit_cli.py:686: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <MagicMock name='exit' id='1829970114080'>, args = (1,), kwargs = {}\nmsg = \"Expected 'exit' to be called once. Called 2 times.\\nCalls: [call(1), call(1)].\"\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n>           raise AssertionError(msg)\nE           AssertionError: Expected 'exit' to be called once. Called 2 times.\nE           Calls: [call(1), call(1)].\n\nC:\\Python313\\Lib\\unittest\\mock.py:990: AssertionError\n---------------------------- Captured stderr call -----------------------------\n\u001b[32m2025-08-17 16:27:58\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in cli.main: cannot access local variable 'result' where it is not associated with a value\u001b[0m\n\u001b[32m2025-08-17 16:27:58\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mshared.utils.error_handler\u001b[0m:\u001b[36mhandle_error\u001b[0m:\u001b[36m87\u001b[0m - \u001b[31m\u001b[1mError in cli.main: cannot access local variable 'result' where it is not associated with a value\u001b[0m\n\u001b[32m2025-08-17 16:27:58\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mcli.commands.track_commit\u001b[0m:\u001b[36mmain\u001b[0m:\u001b[36m73\u001b[0m - \u001b[31m\u001b[1mCLI error: cannot access local variable 'result' where it is not associated with a value\u001b[0m\n\u001b[32m2025-08-17 16:27:58\u001b[0m | \u001b[31m\u001b[1mERROR   \u001b[0m | \u001b[36mcli.commands.track_commit\u001b[0m:\u001b[36mmain\u001b[0m:\u001b[36m73\u001b[0m - \u001b[31m\u001b[1mCLI error: cannot access local variable 'result' where it is not associated with a value\u001b[0m\n============================== warnings summary ===============================\ntest_automation.py:22\n  C:\\Projects\\Pratice_Microservice\\craftnudge-ai-agent\\test_automation.py:22: PytestCollectionWarning: cannot collect test class 'TestAutomationFramework' because it has a __init__ constructor (from: test_automation.py)\n    class TestAutomationFramework:\n\ntests/unit/test_source_files.py: 29 warnings\n  C:\\Projects\\Pratice_Microservice\\craftnudge-ai-agent\\tests\\unit\\test_source_files.py:85: DeprecationWarning: ast.Str is deprecated and will be removed in Python 3.14; use ast.Constant instead\n    if isinstance(tree.body[0].value, ast.Str):\n\ntests/unit/test_source_files.py: 28 warnings\n  C:\\Projects\\Pratice_Microservice\\craftnudge-ai-agent\\tests\\unit\\test_source_files.py:86: DeprecationWarning: Attribute s is deprecated and will be removed in Python 3.14; use value instead\n    docstring = tree.body[0].value.s\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n=============================== tests coverage ================================\n_______________ coverage: platform win32, python 3.13.5-final-0 _______________\n\nName                                                    Stmts   Miss  Cover   Missing\n-------------------------------------------------------------------------------------\n__init__.py                                                 7      0   100%\ncli\\__init__.py                                             0      0   100%\ncli\\commands\\__init__.py                                    0      0   100%\ncli\\commands\\track_commit.py                              184     49    73%   52, 54, 264-270, 284-310, 329, 343, 395-398, 404, 417-420, 429-456, 464\ncli\\utils\\__init__.py                                       3      0   100%\ncli\\utils\\cli_helpers.py                                   25      0   100%\nconftest.py                                                43      6    86%   38-42, 83\nexamples\\__init__.py                                        0      0   100%\nexamples\\basic_usage.py                                    51      1    98%   82\nfinal_coverage_test.py                                    297    113    62%   39-51, 87-88, 103-105, 156-191, 266-303, 356-357, 453, 482-549, 552\nrun_coverage_tests.py                                     352    352     0%   9-635\nrun_tests.py                                              158    158     0%   13-323\nservices\\__init__.py                                        5      2    60%   11-13\nservices\\commit_tracker_service\\__init__.py                 8      2    75%   23-25\nservices\\commit_tracker_service\\src\\__init__.py             5      0   100%\nservices\\commit_tracker_service\\src\\commit_tracker.py      82      3    96%   203-205\nservices\\commit_tracker_service\\src\\data_writer.py        136     16    88%   116-119, 147-150, 191-194, 266-267, 275-276\nservices\\commit_tracker_service\\src\\git_parser.py         142      0   100%\nshared\\__init__.py                                          7      2    71%   20-22\nshared\\config\\__init__.py                                   6      1    83%   12\nshared\\config\\config_manager.py                           100      9    91%   177-181, 225, 229, 281, 286-287\nshared\\utils\\__init__.py                                    7      2    71%   11-13\nshared\\utils\\error_handler.py                              67     10    85%   83-85, 105-108, 128-136\nshared\\utils\\logger.py                                     31      6    81%   42-45, 82, 87-88\ntest_automation.py                                        230    205    11%   26-31, 35-79, 88-151, 155-175, 179-203, 207-231, 235-265, 269-304, 308-313, 317-332, 336-354, 365-379, 383-428, 432-485, 488\ntest_runner.py                                             35     26    26%   18-25, 30-61, 65-74, 77\ntests\\e2e\\__init__.py                                       0      0   100%\ntests\\e2e\\test_commit_tracking_e2e.py                      33      1    97%   111\ntests\\integration\\__init__.py                               0      0   100%\ntests\\integration\\test_cli_integration.py                  34      1    97%   116\ntests\\integration\\test_service_integration.py              37      1    97%   111\ntests\\unit\\__init__.py                                      0      0   100%\ntests\\unit\\test_basic_usage.py                            267      0   100%\ntests\\unit\\test_cli_commands_init.py                      169      0   100%\ntests\\unit\\test_cli_helpers.py                            239      0   100%\ntests\\unit\\test_cli_init.py                               178     14    92%   49-57, 155, 204-208, 256, 280-281\ntests\\unit\\test_cli_utils_init.py                         514     37    93%   342-362, 506-512, 557-577, 656-665\ntests\\unit\\test_commit_tracker.py                         308      0   100%\ntests\\unit\\test_commit_tracker_service_init.py            146     14    90%   49-57, 155, 204-208, 256, 280-281\ntests\\unit\\test_config_manager.py                         286     35    88%   172-174, 183-185, 203-221, 408-409, 418, 508-526, 549-554\ntests\\unit\\test_data_writer.py                            359      5    99%   614, 626-630\ntests\\unit\\test_error_handler.py                          297     59    80%   40, 45-48, 55-57, 119-121, 129-131, 140-141, 149-151, 159-161, 169-170, 192, 202, 212, 230-232, 243-244, 253, 262, 273-274, 283, 292-294, 308, 318, 328, 338, 349-350, 364, 380, 390, 406, 412, 415-416, 435, 466-467, 474, 481-482, 498\ntests\\unit\\test_examples_init.py                          196     14    93%   49-57, 155, 204-208, 256, 280-281\ntests\\unit\\test_git_parser.py                             335      0   100%\ntests\\unit\\test_logger.py                                 117     20    83%   28, 34-35, 42-43, 50-51, 60-61, 67, 144, 175-176, 182-183, 193-194, 205-215\ntests\\unit\\test_root_init.py                              169     84    50%   21, 27, 33-34, 40-41, 47-48, 54-58, 64-67, 74-75, 83-86, 93-94, 123-124, 131-136, 144-150, 156-169, 177-180, 190-194, 205-213, 219-229, 235-240, 246-251, 257-262, 269-276, 288-304\ntests\\unit\\test_root_track_commit.py                      159     18    89%   40-43, 114-119, 164-166, 176-181, 222, 248-253\ntests\\unit\\test_services_init.py                          110     11    90%   49-57, 155, 205-209\ntests\\unit\\test_shared_config_init.py                     272     51    81%   39, 86, 98, 110, 122, 134, 181, 196-204, 284, 306-312, 326-328, 345-353, 367-382, 395-405, 420-423\ntests\\unit\\test_shared_init.py                            165     14    92%   49-57, 155, 203-207, 254, 278-279\ntests\\unit\\test_shared_utils_init.py                      444    103    77%   46, 121-123, 142-151, 170-179, 212, 234-254, 376, 405-411, 432-434, 458-478, 499-532, 552-555, 575-589, 611-616\ntests\\unit\\test_source_files.py                           389    177    54%   45, 63-64, 88-89, 100-112, 119-124, 135-145, 152-158, 164-193, 204-209, 216-221, 251-265, 272-278, 284-293, 299-317, 328-333, 340-345, 375-383, 390-395, 401-416, 427-436, 443-449, 479-487, 494-500, 530-536, 543-547, 603-611, 621-642, 678-679, 733-737, 741\ntests\\unit\\test_track_commit_cli.py                       420     52    88%   49-52, 96, 105, 152-163, 169-192, 198-214, 219-238, 400, 424-427, 457-461\ntrack_commit.py                                             7      1    86%   20\n-------------------------------------------------------------------------------------\nTOTAL                                                    7631   1675    78%\n=========================== short test summary info ===========================\nFAILED final_coverage_test.py::test_config_manager - assert 'import logging' ...\nFAILED final_coverage_test.py::test_error_handler - assert 'import logging' i...\nFAILED tests/unit/test_cli_commands_init.py::TestCLICommandsInit::test_docstring_contains_cli_command\nFAILED tests/unit/test_cli_commands_init.py::TestCLICommandsInit::test_package_abbreviation_consistency\nFAILED tests/unit/test_cli_commands_init.py::TestCLICommandsInit::test_docstring_content_validation\nFAILED tests/unit/test_cli_init.py::TestCLIInit::test_docstring_formatting - ...\nFAILED tests/unit/test_cli_init.py::TestCLIInit::test_docstring_quality - ass...\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_format_commit_message_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_validate_repository_path_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_get_repository_status_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_format_timestamp_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_calculate_commit_stats_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_export_commits_to_format_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_interactive_commit_selection_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_setup_logging_for_cli_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_display_progress_bar_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_confirm_action_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_get_user_input_import\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_import_error_handling_cli_helpers\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_import_statement_order\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_docstring_formatting\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_import_paths_accuracy\nFAILED tests/unit/test_cli_utils_init.py::TestCLIUtilsInit::test_function_availability\nFAILED tests/unit/test_commit_tracker_service_init.py::TestCommitTrackerServiceInit::test_docstring_formatting\nFAILED tests/unit/test_commit_tracker_service_init.py::TestCommitTrackerServiceInit::test_docstring_quality\nFAILED tests/unit/test_commit_tracker_service_init.py::TestCommitTrackerServiceInit::test_package_initialization_cleanliness\nFAILED tests/unit/test_config_manager.py::TestLoadConfigFile::test_load_config_file_invalid_yaml\nFAILED tests/unit/test_config_manager.py::TestLoadConfigFile::test_load_config_file_not_dict\nFAILED tests/unit/test_config_manager.py::TestLoadConfigFile::test_load_config_file_file_not_found\nFAILED tests/unit/test_config_manager.py::TestLoadConfigFile::test_load_config_file_permission_error\nFAILED tests/unit/test_config_manager.py::TestCreateDefaultConfig::test_create_default_config_creates_file\nFAILED tests/unit/test_config_manager.py::TestCreateDefaultConfig::test_create_default_config_creates_directory\nFAILED tests/unit/test_config_manager.py::TestCreateDefaultConfig::test_create_default_config_handles_write_error\nFAILED tests/unit/test_config_manager.py::TestCreateDefaultConfig::test_create_default_config_content_structure\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_missing_required_section\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_section_not_dict\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_missing_data_store_base_path\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_missing_required_service\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_service_not_dict\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_missing_logging_level\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_invalid_logging_level[INVALID]\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_invalid_logging_level[DEBUGGING]\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_invalid_logging_level[TRACE]\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_invalid_logging_level[FATAL]\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_valid_logging_levels[DEBUG]\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_valid_logging_levels[INFO]\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_valid_logging_levels[WARNING]\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_valid_logging_levels[ERROR]\nFAILED tests/unit/test_config_manager.py::TestValidateConfig::test_validate_config_valid_logging_levels[CRITICAL]\nFAILED tests/unit/test_config_manager.py::TestUpdateConfig::test_update_config_simple_update\nFAILED tests/unit/test_config_manager.py::TestUpdateConfig::test_update_config_loads_if_cache_empty\nFAILED tests/unit/test_config_manager.py::TestUpdateConfig::test_update_config_handles_validation_error\nFAILED tests/unit/test_config_manager.py::TestConfigManagerIntegration::test_full_config_lifecycle\nFAILED tests/unit/test_config_manager.py::TestConfigManagerIntegration::test_config_with_real_file\nFAILED tests/unit/test_data_writer.py::TestDataWriter::test_ensure_data_store_exists_success\nFAILED tests/unit/test_data_writer.py::TestDataWriter::test_ensure_data_store_exists_error\nFAILED tests/unit/test_error_handler.py::TestCraftNudgeError::test_craft_nudge_error_initialization\nFAILED tests/unit/test_error_handler.py::TestCraftNudgeError::test_craft_nudge_error_default_parameters\nFAILED tests/unit/test_error_handler.py::TestCraftNudgeError::test_craft_nudge_error_timestamp_format\nFAILED tests/unit/test_error_handler.py::TestHandleError::test_handle_error_basic_exception\nFAILED tests/unit/test_error_handler.py::TestHandleError::test_handle_error_with_error_code\nFAILED tests/unit/test_error_handler.py::TestHandleError::test_handle_error_with_details\nFAILED tests/unit/test_error_handler.py::TestHandleError::test_handle_error_craft_nudge_error\nFAILED tests/unit/test_error_handler.py::TestHandleError::test_handle_error_timestamp_format\nFAILED tests/unit/test_error_handler.py::TestHandleError::test_handle_error_traceback_included\nFAILED tests/unit/test_error_handler.py::TestValidateRequiredFields::test_validate_required_fields_success\nFAILED tests/unit/test_error_handler.py::TestValidateRequiredFields::test_validate_required_fields_missing_field\nFAILED tests/unit/test_error_handler.py::TestValidateRequiredFields::test_validate_required_fields_none_value\nFAILED tests/unit/test_error_handler.py::TestValidateRequiredFields::test_validate_required_fields_empty_data\nFAILED tests/unit/test_error_handler.py::TestValidateRequiredFields::test_validate_required_fields_empty_required_list\nFAILED tests/unit/test_error_handler.py::TestValidateRequiredFields::test_validate_required_fields_context_in_error\nFAILED tests/unit/test_error_handler.py::TestValidateFieldType::test_validate_field_type_success\nFAILED tests/unit/test_error_handler.py::TestValidateFieldType::test_validate_field_type_missing_field\nFAILED tests/unit/test_error_handler.py::TestValidateFieldType::test_validate_field_type_wrong_type\nFAILED tests/unit/test_error_handler.py::TestValidateFieldType::test_validate_field_type_complex_types\nFAILED tests/unit/test_error_handler.py::TestValidateFieldType::test_validate_field_type_none_value\nFAILED tests/unit/test_error_handler.py::TestValidateFieldType::test_validate_field_type_context_in_error\nFAILED tests/unit/test_error_handler.py::TestSafeExecute::test_safe_execute_success\nFAILED tests/unit/test_error_handler.py::TestSafeExecute::test_safe_execute_with_kwargs\nFAILED tests/unit/test_error_handler.py::TestSafeExecute::test_safe_execute_function_failure\nFAILED tests/unit/test_error_handler.py::TestSafeExecute::test_safe_execute_with_complex_return_value\nFAILED tests/unit/test_error_handler.py::TestSafeExecute::test_safe_execute_function_name_in_context\nFAILED tests/unit/test_error_handler.py::TestRetryOnError::test_retry_on_error_success_first_attempt\nFAILED tests/unit/test_error_handler.py::TestRetryOnError::test_retry_on_error_success_after_retries\nFAILED tests/unit/test_error_handler.py::TestRetryOnError::test_retry_on_error_all_attempts_fail\nFAILED tests/unit/test_error_handler.py::TestRetryOnError::test_retry_on_error_custom_parameters\nFAILED tests/unit/test_error_handler.py::TestRetryOnError::test_retry_on_error_with_args_kwargs\nFAILED tests/unit/test_error_handler.py::TestRetryOnError::test_retry_on_error_logging\nFAILED tests/unit/test_error_handler.py::TestRetryOnError::test_retry_on_error_zero_retries\nFAILED tests/unit/test_error_handler.py::TestErrorHandlerIntegration::test_error_chain_with_validation\nFAILED tests/unit/test_error_handler.py::TestErrorHandlerIntegration::test_safe_execute_with_validation\nFAILED tests/unit/test_error_handler.py::TestErrorHandlerIntegration::test_retry_on_error_with_safe_execute\nFAILED tests/unit/test_examples_init.py::TestExamplesInit::test_docstring_formatting\nFAILED tests/unit/test_examples_init.py::TestExamplesInit::test_docstring_quality\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_default_parameters\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_custom_level\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_with_file - T...\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_custom_format\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_creates_log_directory\nFAILED tests/unit/test_logger.py::TestLogger::test_get_logger_returns_logger_instance\nFAILED tests/unit/test_logger.py::TestLogger::test_get_logger_with_module_name\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_integration\nFAILED tests/unit/test_logger.py::TestLogger::test_logger_removes_default_handler\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_clears_standard_logging_handlers\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_valid_levels[DEBUG]\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_valid_levels[INFO]\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_valid_levels[WARNING]\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_valid_levels[ERROR]\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_valid_levels[CRITICAL]\nFAILED tests/unit/test_logger.py::TestLogger::test_setup_logger_invalid_level\nFAILED tests/unit/test_logger.py::TestLogger::test_get_logger_edge_cases - As...\nFAILED tests/unit/test_logger.py::TestLogger::test_intercept_handler_edge_cases\nFAILED tests/unit/test_root_init.py::TestRootInit::test_package_version - Mod...\nFAILED tests/unit/test_root_init.py::TestRootInit::test_package_author - Modu...\nFAILED tests/unit/test_root_init.py::TestRootInit::test_package_description\nFAILED tests/unit/test_root_init.py::TestRootInit::test_package_docstring - M...\nFAILED tests/unit/test_root_init.py::TestRootInit::test_all_list_definition\nFAILED tests/unit/test_root_init.py::TestRootInit::test_commit_tracker_import\nFAILED tests/unit/test_root_init.py::TestRootInit::test_logger_imports - Modu...\nFAILED tests/unit/test_root_init.py::TestRootInit::test_config_import - Modul...\nFAILED tests/unit/test_root_init.py::TestRootInit::test_all_imports_available\nFAILED tests/unit/test_root_init.py::TestRootInit::test_import_statement_order\nFAILED tests/unit/test_root_init.py::TestRootInit::test_package_metadata_consistency\nFAILED tests/unit/test_root_init.py::TestRootInit::test_module_attributes_existence\nFAILED tests/unit/test_root_init.py::TestRootInit::test_import_performance - ...\nFAILED tests/unit/test_root_init.py::TestRootInit::test_multiple_imports_behavior\nFAILED tests/unit/test_root_init.py::TestRootInit::test_export_consistency - ...\nFAILED tests/unit/test_root_init.py::TestRootInit::test_docstring_formatting\nFAILED tests/unit/test_root_init.py::TestRootInit::test_version_format - Modu...\nFAILED tests/unit/test_root_init.py::TestRootInit::test_author_format - Modul...\nFAILED tests/unit/test_root_init.py::TestRootInit::test_description_format - ...\nFAILED tests/unit/test_root_init.py::TestRootInit::test_import_paths_accuracy\nFAILED tests/unit/test_root_init.py::TestRootInit::test_package_initialization_completeness\nFAILED tests/unit/test_root_track_commit.py::TestRootTrackCommit::test_sys_path_modification\nFAILED tests/unit/test_root_track_commit.py::TestRootTrackCommit::test_main_function_execution\nFAILED tests/unit/test_root_track_commit.py::TestRootTrackCommit::test_sys_path_insertion_order\nFAILED tests/unit/test_root_track_commit.py::TestRootTrackCommit::test_sys_path_modification_preserves_existing\nFAILED tests/unit/test_root_track_commit.py::TestRootTrackCommit::test_multiple_imports_behavior\nFAILED tests/unit/test_root_track_commit.py::TestRootTrackCommit::test_import_statement_order\nFAILED tests/unit/test_root_track_commit.py::TestRootTrackCommit::test_sys_path_insertion_with_string_conversion\nFAILED tests/unit/test_services_init.py::TestServicesInit::test_docstring_formatting\nFAILED tests/unit/test_services_init.py::TestServicesInit::test_docstring_quality\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_package_version\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_all_list_definition\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_get_config_import\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_get_config_value_import\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_reload_config_import\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_update_config_import\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_create_default_config_import\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_import_error_handling_get_config\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_import_error_handling_get_config_value\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_import_error_handling_reload_config\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_import_error_handling_update_config\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_import_error_handling_create_default_config\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_import_statement_order\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_package_metadata_consistency\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_module_attributes_existence\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_multiple_imports_behavior\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_export_consistency\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_docstring_formatting\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_version_format\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_import_paths_accuracy\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_package_initialization_completeness\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_function_availability\nFAILED tests/unit/test_shared_config_init.py::TestSharedConfigInit::test_function_signatures\nFAILED tests/unit/test_shared_init.py::TestSharedInit::test_docstring_formatting\nFAILED tests/unit/test_shared_init.py::TestSharedInit::test_docstring_quality\nFAILED tests/unit/test_shared_init.py::TestSharedInit::test_package_initialization_cleanliness\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_package_version\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_all_list_definition\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_logger_imports\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_error_classes_imports\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_error_handler_functions_imports\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_import_error_handling_logger\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_import_error_handling_error_handler\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_import_statement_order\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_package_metadata_consistency\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_module_attributes_existence\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_multiple_imports_behavior\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_export_consistency\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_docstring_formatting\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_version_format\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_import_paths_accuracy\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_package_initialization_completeness\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_error_class_inheritance\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_function_availability\nFAILED tests/unit/test_shared_utils_init.py::TestSharedUtilsInit::test_function_signatures\nFAILED tests/unit/test_source_files.py::TestSourceFileAnalysis::test_all_python_files_exist\nFAILED tests/unit/test_source_files.py::TestTrackCommitFile::test_track_commit_file_structure\nFAILED tests/unit/test_source_files.py::TestTrackCommitFile::test_track_commit_imports\nFAILED tests/unit/test_source_files.py::TestConfigManager::test_config_manager_file_structure\nFAILED tests/unit/test_source_files.py::TestConfigManager::test_config_manager_imports\nFAILED tests/unit/test_source_files.py::TestConfigManager::test_config_manager_functions\nFAILED tests/unit/test_source_files.py::TestLogger::test_logger_file_structure\nFAILED tests/unit/test_source_files.py::TestLogger::test_logger_imports - Fil...\nFAILED tests/unit/test_source_files.py::TestErrorHandler::test_error_handler_file_structure\nFAILED tests/unit/test_source_files.py::TestErrorHandler::test_error_handler_imports\nFAILED tests/unit/test_source_files.py::TestErrorHandler::test_error_handler_classes\nFAILED tests/unit/test_source_files.py::TestErrorHandler::test_error_handler_functions\nFAILED tests/unit/test_source_files.py::TestCLICommands::test_cli_commands_file_structure\nFAILED tests/unit/test_source_files.py::TestCLICommands::test_cli_commands_imports\nFAILED tests/unit/test_source_files.py::TestCommitTracker::test_commit_tracker_file_structure\nFAILED tests/unit/test_source_files.py::TestCommitTracker::test_commit_tracker_imports\nFAILED tests/unit/test_source_files.py::TestCommitTracker::test_commit_tracker_class\nFAILED tests/unit/test_source_files.py::TestGitParser::test_git_parser_file_structure\nFAILED tests/unit/test_source_files.py::TestGitParser::test_git_parser_imports\nFAILED tests/unit/test_source_files.py::TestDataWriter::test_data_writer_file_structure\nFAILED tests/unit/test_source_files.py::TestDataWriter::test_data_writer_imports\nFAILED tests/unit/test_source_files.py::TestBasicUsage::test_basic_usage_file_structure\nFAILED tests/unit/test_source_files.py::TestBasicUsage::test_basic_usage_imports\nFAILED tests/unit/test_source_files.py::TestIntegration::test_cli_integration\nFAILED tests/unit/test_source_files.py::TestCoverage::test_all_functions_covered\nFAILED tests/unit/test_source_files.py::TestCoverage::test_all_classes_covered\nFAILED tests/unit/test_track_commit_cli.py::TestArgumentParser::test_parser_has_subcommands\nFAILED tests/unit/test_track_commit_cli.py::TestArgumentParser::test_latest_command_parser\nFAILED tests/unit/test_track_commit_cli.py::TestArgumentParser::test_output_format_choices[json]\nFAILED tests/unit/test_track_commit_cli.py::TestArgumentParser::test_output_format_choices[text]\nFAILED tests/unit/test_track_commit_cli.py::TestArgumentParser::test_output_format_choices[table]\nFAILED tests/unit/test_track_commit_cli.py::TestArgumentParser::test_log_level_choices[DEBUG]\nFAILED tests/unit/test_track_commit_cli.py::TestArgumentParser::test_log_level_choices[INFO]\nFAILED tests/unit/test_track_commit_cli.py::TestArgumentParser::test_log_level_choices[WARNING]\nFAILED tests/unit/test_track_commit_cli.py::TestArgumentParser::test_log_level_choices[ERROR]\nFAILED tests/unit/test_track_commit_cli.py::TestCLIFunctions::test_list_commits\nFAILED tests/unit/test_track_commit_cli.py::TestCLIFunctions::test_search_commits_with_criteria\nFAILED tests/unit/test_track_commit_cli.py::TestCLIFunctions::test_search_commits_without_criteria\nFAILED tests/unit/test_track_commit_cli.py::TestCLIFunctions::test_search_commits_applies_limit\nFAILED tests/unit/test_track_commit_cli.py::TestOutputFunctions::test_output_text_result_commits_list\nFAILED tests/unit/test_track_commit_cli.py::TestOutputFunctions::test_output_table_result_no_tabulate\nFAILED tests/unit/test_track_commit_cli.py::TestOutputFunctions::test_output_table_result_with_commits\nFAILED tests/unit/test_track_commit_cli.py::TestMainFunction::test_main_unknown_command\n230 failed, 528 passed, 58 warnings in 23.36s\n",
    "status": "COMPLETED"
  },
  "quality": {
    "pylint": {
      "status": "FAILED",
      "score": 0
    },
    "flake8": {
      "status": "FAILED",
      "score": 0
    },
    "mypy": {
      "status": "FAILED",
      "score": 0
    }
  },
  "summary": {
    "total_modules": 12,
    "passed_modules": 12,
    "coverage": 78.0,
    "quality_score": 0.0,
    "grade": "C",
    "duration": 54.031700134277344
  }
}